<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2023-05-02T15:00:00+09:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>tsyringe を TypeScript 5 で使う方法</title>
    <link rel="alternate" href="http://blog.url.com/2023/05/02/tsyringe-with-typescript-5.html"/>
    <id>http://blog.url.com/2023/05/02/tsyringe-with-typescript-5.html</id>
    <published>2023-05-02T15:00:00+09:00</published>
    <updated>2023-05-02T15:17:42+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="https://github.com/microsoft/tsyringe"&gt;tsyringe&lt;/a&gt; は、Microsoft のオーガナイゼーションにある、JavaScript/TypeScript用のDIコンテナです。&lt;/p&gt;

&lt;p&gt;Microsoft は TypeScript の親だし、DIコンテナあるんだったら使うよなーというぐらいの理由で使っていましたが、ここ数年はアップデートのリリースがありません。
この記事を書いている時点での最新版は、2020/11/9 に出た &lt;a href="https://github.com/microsoft/tsyringe/releases/tag/v4.4.0"&gt;v4.4.0&lt;/a&gt; です。&lt;/p&gt;

&lt;h3&gt;TypeScript 5 でコンパイルエラーになる&lt;/h3&gt;

&lt;p&gt;tsyringe を TypeScript 5 で利用しようとすると、コンパイルエラーになります。
で、さすがに利用者が多いライブラリだけあって、すぐ issue &lt;a href="https://github.com/microsoft/tsyringe/issues/221"&gt;TypeScript 5.0 Support of tighter parameter decorator checking&lt;/a&gt; が出ました。
しばらくしたら PR &lt;a href="https://github.com/microsoft/tsyringe/pull/226"&gt;fix: allow propertyKey to be undefined&lt;/a&gt; も出ました。PRが 2023/3/26 に出て、マージされたのは 2023/4/17 です。&lt;/p&gt;

&lt;p&gt;それから2週間ぐらい経過しましたが、リリースされる気配はありません&amp;hellip;.&lt;/p&gt;

&lt;h3&gt;でも TypeScript 5 を使いたいんや&lt;/h3&gt;

&lt;p&gt;まぁそう思いますよね。
僕らのプロジェクトでもそう思ったんで、パッチを作りました。&lt;/p&gt;

&lt;p&gt;プロジェクトルート(package.json とか置いているディレクトリ)に &lt;code&gt;tsyringe.d.ts&lt;/code&gt; を置いて、型定義をオーバーライドする感じです。
例えば以下のような感じです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;require&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;tsyringe/dist/typings/index&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;declare&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;inject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;InjectionToken&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;any&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;target&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;any&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;propertyKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;undefined&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parameterIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;any&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;injectable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;injectable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;DependencyContainer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まずコンパイルエラーになるのは &lt;code&gt;inject&lt;/code&gt; 関数なので、それをオーバーライドします。
次に、プロジェクトで import している関数や型があれば、それぞれ &lt;code&gt;const&lt;/code&gt; や &lt;code&gt;type&lt;/code&gt; で宣言して require した内容からそのまま export するようにしました。&lt;/p&gt;

&lt;p&gt;これはマージされている PR が型定義ぐらいしか修正しておらず、実装に関しては何も修正されていなかったので、問題なしと判断して型定義だけをオーバーライドしたパッチを作ることにしました。&lt;/p&gt;

&lt;h3&gt;で、どうなの？&lt;/h3&gt;

&lt;p&gt;現時点動作に問題はなく、普通に TypeScript 5 で tsyringe が使えています。
PRがマージされて、すぐリリースされるんじゃないか？と思ったので、この内容を記事にする必要もないかな？と思っていたのですが、
リリースされる気配を感じないので、僕らのやっている方法が少しでも役に立てばと思い、記事にしました。
はやく TypeScript 5 対応が正式リリースされて欲しいですね。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>LocalStack を使って aws-sdk の Integration Test を実行する</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/19/integration-test-using-localstack.html"/>
    <id>http://blog.url.com/2023/04/19/integration-test-using-localstack.html</id>
    <published>2023-04-19T16:12:00+09:00</published>
    <updated>2023-04-19T16:38:55+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="/2023/01/04/migrate-aws-sdk-node-js-v2-to-v3.html"&gt;AWS Lambda の Node.js 14 を 18 に移行する（aws-sdk v3 移行編）&lt;/a&gt; の中でも書いたように、aws-sdk v3 を使ったコードを UnitTest するには &lt;a href="https://github.com/m-radzikowski/aws-sdk-client-mock"&gt;AWS SDK v3 Client mock&lt;/a&gt; を利用してモックした方が簡単です。&lt;/p&gt;

&lt;p&gt;一方で少し IntegrationTest をしたいと思うこともあるでしょう。そうしたときは LocalStack の利用が便利です。
手元も環境なら Docker の Extension で動きます。
CI 環境、たとえば GitHub Actions ならサービスでコンテナ起動すれば大丈夫です。&lt;/p&gt;

&lt;h3&gt;インテグレーションテストでのエンドポイント&lt;/h3&gt;

&lt;p&gt;こんな感じでテストコードで endpoint を切り替えられるようにしておくとローカルとCI環境のどちらでもテストを実行しやすくなります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="na"&gt;credentials&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="na"&gt;accessKeyId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;dummy&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="na"&gt;secretAccessKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;summy&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="na"&gt;endpoint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;`http://&lt;/span&gt;&lt;span class="p"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;env&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TEST_AWS_HOSTNAME&lt;/span&gt; &lt;span class="o"&gt;??&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;localhost&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;:4566`&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="na"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;ap-northeast-1&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;stepFunctions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;SFNClient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;options&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;手元では localhost で良いし、CI環境（たとえば GitHub Actions ） なら、以下のようにしておくと良いです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;    &lt;span class="na"&gt;container&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;node:18&lt;/span&gt;
    &lt;span class="na"&gt;services&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;localstack&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
        &lt;span class="na"&gt;image&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;localstack/localstack&lt;/span&gt;
    &lt;span class="na"&gt;env&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;TEST_AWS_HOSTNAME&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;localstack&lt;/span&gt;
    &lt;span class="na"&gt;steps&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;LocalStack v2.0 以降での変更点&lt;/h3&gt;

&lt;p&gt;最近バージョンが 2.0 になった LocalStack ですが Lambda 関連で大きな変更がありました。
基本的に Lambda を利用しなければ問題はありませんが、特に問題なければ localstack サービスを以下のように設定しておくと安心です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;    &lt;span class="na"&gt;container&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;node:18&lt;/span&gt;
    &lt;span class="na"&gt;services&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;localstack&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
        &lt;span class="na"&gt;image&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;localstack/localstack&lt;/span&gt;
        &lt;span class="na"&gt;env&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
          &lt;span class="na"&gt;LAMBDA_SYNCHRONOUS_CREATE&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
        &lt;span class="na"&gt;volumes&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
          &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;/var/run/docker.sock:/var/run/docker.sock&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Actions のホストコントローラの docker.sock をマウントすることで LocalStack の中で Lambda が起動できるようになります。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href="https://github.com/localstack/localstack/releases/tag/v2.0.0"&gt;公式の v2.0.0 リリースノート&lt;/a&gt; の &lt;code&gt;Lambda&lt;/code&gt; 部分に書いてありますので、読んでみてください。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;単体テストで LocalStack 使うのはやりすぎだと思いますが、部分的にインテグレーションテストしたい、といった場合には有用な方法かな、と思いますので、用途に応じて使い分けられると良いですね。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>AWS SDK v3 のモジュールと利用方法</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/18/generation-code-aws-sdk-v3.html"/>
    <id>http://blog.url.com/2023/04/18/generation-code-aws-sdk-v3.html</id>
    <published>2023-04-18T12:21:00+09:00</published>
    <updated>2023-04-18T15:01:28+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;このところ何度か aws-sdk v3 について記事を書いてきましたが、こちらは現時点でのベストプラクティスというか、追記を含むまとめ記事になります。&lt;/p&gt;

&lt;h3&gt;ランタイムに含まれないモジュールがある？&lt;/h3&gt;

&lt;p&gt;aws-sdk を使って Lambda から Lambda を実行するときのコードは、公式のExampleコードを見ると以下のようになっています。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/awsdocs/aws-doc-sdk-examples/blob/main/javascriptv3/example_code/lambda/actions/invoke.js"&gt;https://github.com/awsdocs/aws-doc-sdk-examples/blob/main/javascriptv3/example_code/lambda/actions/invoke.js&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="cm"&gt;/**
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LambdaClient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LogType&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/client-lambda&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;createClientForDefaultRegion&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;../../libs/utils/util-aws-sdk.js&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/** snippet-start:[javascript.v3.lambda.actions.Invoke] */&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;invoke&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;funcName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;createClientForDefaultRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;LambdaClient&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="na"&gt;FunctionName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;funcName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="na"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;stringify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="na"&gt;LogType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;LogType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;});&lt;/span&gt;

  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LogResult&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;command&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;logs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;LogResult&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;base64&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;logs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="cm"&gt;/** snippet-end:[javascript.v3.lambda.actions.Invoke] */&lt;/span&gt;

&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;invoke&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで注目して欲しいのは&lt;/p&gt;

&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Payload: JSON.stringify(payload),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;の部分なのですが、これは TypeScript で記述すると型違反でエラーになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;    &lt;span class="cm"&gt;/**
     * &amp;lt;p&amp;gt;The JSON that you want to provide to your Lambda function as input.&amp;lt;/p&amp;gt;
     *          &amp;lt;p&amp;gt;You can enter the JSON directly. For example, &amp;lt;code&amp;gt;--payload '\{ "key": "value" \}'&amp;lt;/code&amp;gt;. You can also
     *       specify a file path. For example, &amp;lt;code&amp;gt;--payload file://payload.json&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
     */&lt;/span&gt;
    &lt;span class="nx"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;?:&lt;/span&gt; &lt;span class="nb"&gt;Uint8Array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;公式 Example のコードの意味とは&amp;hellip; というところですが、&lt;/p&gt;

&lt;p&gt;で、そういう issue やら SlackOverflow があって&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/aws/aws-sdk-js-v3/issues/4623"&gt;https://github.com/aws/aws-sdk-js-v3/issues/4623&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;InvocationType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LambdaClient&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/client-lambda&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;toUint8Array&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/util-utf8&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;lambda&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;LambdaClient&lt;/span&gt;&lt;span class="p"&gt;({});&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
      &lt;span class="na"&gt;FunctionName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;env&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LAMBDA_ARN&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="na"&gt;InvocationType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;InvocationType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RequestResponse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="na"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;toUint8Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}),&lt;/span&gt;
  &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こんな感じで &lt;code&gt;Uint8Array&lt;/code&gt; に変換する必要があります。
そこで &lt;code&gt;@aws-sdk/util-utf8&lt;/code&gt; を使ったのですが、これが Node.js v18 の Lambda インスタンスだと見つからないとエラーになります。&lt;/p&gt;

&lt;h3&gt;執筆時点での Lambda インスタンスの sdk バージョンは 3.188.0&lt;/h3&gt;

&lt;p&gt;以下のページから現在のランタイムに入っている sdk バージョンがわかります。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtimes.html"&gt;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtimes.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;執筆時点では 3.188.0 なので、 GitHub リポジトリでそのタグのコードを見てみると、確かにそんなパッケージはありません。
それどころか、 &lt;code&gt;@aws-sdk/util-utf8-node&lt;/code&gt; と &lt;code&gt;@aws-sdk/util-utf8-browser&lt;/code&gt; という2つのパッケージに分かれていました。
どうも、3.300.0 あたりでパッケージを統合したようです。&lt;/p&gt;

&lt;p&gt;NPMのレジストリをみると、&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.npmjs.com/package/@aws-sdk/util-utf8-node"&gt;https://www.npmjs.com/package/@aws-sdk/util-utf8-node&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Deprecated package&lt;/p&gt;

&lt;p&gt;This internal package is deprecated in favor of @aws-sdk/util-utf8.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;のように書いてあります。&lt;/p&gt;

&lt;p&gt;ちなみに、最新の GitHub リポジトリからは、 &lt;code&gt;util-utf8-node&lt;/code&gt; が完全に削除されています。&lt;/p&gt;

&lt;h3&gt;状況を整理し、これから発生することを整理&lt;/h3&gt;

&lt;p&gt;つまり、 3.188.0 で &lt;code&gt;@aws-sdk/util-utf8-node&lt;/code&gt; を使っていて、Lambda の zip に sdk を含めていない人は、ランタイムのアップデートで突然 Lambda が動かなくなる可能性があるということです。&lt;/p&gt;

&lt;p&gt;これはセマンティックバージョニングとしては破壊的変更なのでメジャーバージョンアップ相当ですが、そもそも aws-sdk がセマンティックバージョニングされているかどうかはわかりません（たぶんされていない）。&lt;/p&gt;

&lt;p&gt;僕は長い間、公式ドキュメント「.zip ファイルアーカイブで Node.js Lambda 関数をデプロイする」に書いてある&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;関数が標準ライブラリまたは AWS SDK ライブラリにのみ依存する場合は、これらのライブラリを .zip ファイルに含める必要はありません&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/nodejs-package.html"&gt;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/nodejs-package.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;というポリシーを信じていました。
著名な Serverless Framework でもデフォルトの挙動では zip ファイルを作成するときに aws-sdk を除外するようになってます。&lt;/p&gt;

&lt;h3&gt;道を間違える前に AWS さんに確認してみた&lt;/h3&gt;

&lt;p&gt;僕の懸念は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aws-sdk は zip に含めるべきか？&lt;/li&gt;
&lt;li&gt;後方互換性がなくなる変更があるけど、アップデートの方針はどうなっているか？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というあたりです。&lt;/p&gt;

&lt;h4&gt;aws-sdk は zip に含めるべきか？&lt;/h4&gt;

&lt;p&gt;こちらは「はい」が正解ということです。
&lt;a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/best-practices.html"&gt;AWS Lambda 関数を使用するためのベストプラクティス&lt;/a&gt; に &lt;code&gt;関数のデプロイパッケージ内で依存関係を制御します&lt;/code&gt; という部分があり、zip に含めた方が良いとなっています。&lt;/p&gt;

&lt;p&gt;しかし aws-sdk のサイズはモジュール化されているとはいえ、Lambdaの上限サイズを考えるとかなりの割合を占めてしまうので、できればランタイムを使いたいとことです。&lt;/p&gt;

&lt;h4&gt;後方互換性がなくなる変更があるけど、アップデートの方針はどうなっているか？&lt;/h4&gt;

&lt;p&gt;こちらの回答をふりかえる前に、aws-sdk v3 のモジュール構造について補足しておきます。
GitHub のリポジトリにある README &lt;a href="https://github.com/aws/aws-sdk-js-v3#generated-code"&gt;Generated Code&lt;/a&gt;] によると以下のとおりです。ざっくり要約しました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;v3 コードベースは、AWSサービスが公開しているモデルから生成されています。
smithy-typescript で &lt;code&gt;/clients&lt;/code&gt; サブディレクトリ内のコードを生成し、これらのパッケージは @aws-sdk/client-XXXX のような名前になります。&lt;/p&gt;

&lt;p&gt;クライアントは、 &lt;code&gt;/packages&lt;/code&gt; にあるユーティリティコードに依存します。これらのコードは手動で記述されていて、通常あまり役に立ちません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/lib&lt;/code&gt; には高レベルのライブラリがあります。 client をラップして操作しやすくするライブラリです。よくある例は &lt;code&gt;@aws-sdk/lib-dynamodb&lt;/code&gt; で Amazon DynamoDB のアイテムの操作を簡素化するものや、 &lt;code&gt;@aws-sdk/lib-storage&lt;/code&gt; で S3 の multipartUpload での並列アップロードを簡素化するものです。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;続けて、以下のようにも書いてあります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;/packages 手動でコード更新が行われる場所で、 NPM に @aws-sdk/XXXX で公開されています。特別なプレフィックスはありません。&lt;/li&gt;
&lt;li&gt;/clients  このディレクトリのコードは自動生成され、 /packages に依存します。AWS のサービスと 1 対 1 です。通常、手動編集はここでは行わないでください。@aws-sdk/client-XXXX で NPM に公開されます。&lt;/li&gt;
&lt;li&gt;/lib このディレクトリは、 /clients に依存します。既存の AWS サービスと操作をラップして、Javascript での作業を容易にします。@aws-sdk/lib-XXXX で NPM に公開されています。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上記以外にも private というのもあったりしますが、これは名前からも明らかに非公開のモジュールだとわかります。
NPM 公開されていて、僕らが利用することができるものが client / packages / lib にあるといった感じでしょうか。&lt;/p&gt;

&lt;p&gt;上記3つのディレクトリについての AWS アップデートポリシーは以下のようなものになるそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;client ユーザーが利用する想定のモジュールであり、破壊的変更は行われない&lt;/li&gt;
&lt;li&gt;lib ユーザーが利用する想定のモジュールであり、破壊的変更は行われない&lt;/li&gt;
&lt;li&gt;package client からの利用を想定している内部モジュールなので破壊的変更の可能性がある（ただしドキュメントに明示されていない）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;package に入っているもので、README に利用方法が解説されているもの、たとえば S3 の署名付きURLを発行するためのライブラリ &lt;a href="https://github.com/aws/aws-sdk-js-v3/tree/main/packages/s3-request-presigner"&gt;@aws-sdk/s3-request-presigner&lt;/a&gt; はユーザーからの利用が想定されていて、破壊的変更は行われないようです。
しかし、README にAPIの解説がないものについては内部利用を想定しているため、破壊的変更もありえると。&lt;/p&gt;

&lt;p&gt;後者は private ディレクトリに入れた方が良いのでは？と思わなくはないですが、何か理由があるんでしょうかね。&lt;/p&gt;

&lt;p&gt;今回のようにドキュメントに記述がない &lt;code&gt;@aws-sdk/util-utf8-node&lt;/code&gt; を使いたい場合は zip に必ず含むようにしましょう。
それ以外は zip の容量が厳しければ v2 のときと同じようにランタイムに依存する方が良いと思います。aws-sdk の更新頻度がかなり多いので、どれがセキュリティパッチかわからないし、できればランタイムでの更新に期待したいという思いもあります。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;これまでの aws-sdk v3 / Node.js v18 への移行記事を一覧にしてみます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="/2022/12/30/migrate-aws-lambda-node-js-14-to-18.html"&gt;AWS Lambda の Node.js 14 を 18 に移行する（CI/CD環境移行編）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/01/04/migrate-aws-sdk-node-js-v2-to-v3.html"&gt;AWS Lambda の Node.js 14 を 18 に移行する（aws-sdk v3 移行編）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/03/aws-sdk-v3-ts2345.html"&gt;aws-sdk v3 で TS2345 が出てコンパイルエラーになる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/04/aws-sdk-v3-compile-error-2.html"&gt;aws-sdk v3 でコンパイルエラーになる - その２&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/05/aws-sdk-v3-changed-enum-to-const.html"&gt;Node.js v18 / aws-sdk v3 の Lambda アプリが突然動かなくなる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/11/aws-sdk-v3-to-peer-for-your-library.html"&gt;aws-sdk v3 を使うライブラリを作ったときは、なるべく peerDependencies に設定しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本記事&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;私の思う現時点でのベストプラクティス&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CIのイメージは公式の Lambda Docker イメージが便利&lt;/li&gt;
&lt;li&gt;aws-sdk v3 のユニットテストには aws-sdk-client-mock が良い&lt;/li&gt;
&lt;li&gt;aws-sdk の各モジュールのバージョンは揃えて、なるべく最新を使おう&lt;/li&gt;
&lt;li&gt;aws-sdk 関数/クラス以外、たとえば enum の値などは基本的に利用しない&lt;/li&gt;
&lt;li&gt;peerDependencies に書いてあるモジュールもバージョンを揃えてインストールしよう&lt;/li&gt;
&lt;li&gt;packages にあるドキュメントなしのモジュールを使う場合は、zip に含める

&lt;ul&gt;
&lt;li&gt;zip の容量に余裕があれば aws-sdk はすべて含めた方が良い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;現時点はかなりクセがあるというか、ノウハウが必要であるというのが現実だと思います。
とくに AWS Lambda + aws-sdk v3 + TypeScript の場合にはですね。&lt;/p&gt;

&lt;p&gt;ぶっちゃけ TypeScript でなければコンパイルエラーや型違反についての問題もないし、しいていえば zip に含めるかどうか？ぐらいです。
とはいえ、みんなもう Node.js ランタイム選ぶなら TypeScript 使うだろうと思うので、これまでの記事のノウハウが役に立てば幸いです。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ts-jest が esbuild/swc をトランスフォーマーに使って高速化していた</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/13/ts-jest-will-gradually-opt-in-adoption-of-esbuild-swc-more-to-improve-the-performance.html"/>
    <id>http://blog.url.com/2023/04/13/ts-jest-will-gradually-opt-in-adoption-of-esbuild-swc-more-to-improve-the-performance.html</id>
    <published>2023-04-13T14:54:00+09:00</published>
    <updated>2023-04-13T15:09:00+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;昨年 &lt;a href="/2022/05/03/swc-node-jest.html"&gt;@swc-node/jest を使ってテストを高速化する&lt;/a&gt; という記事を書きました。
その時点で ts-jest でのテストが遅くて、 &lt;code&gt;@swc-node/jest&lt;/code&gt; に切り替えていました。&lt;/p&gt;

&lt;p&gt;その後 &lt;code&gt;@swc-node/jest&lt;/code&gt; もなんやかんやあって、たまに動かなくなったりして issue 投稿して直してもらったりいろいろあったのですが、最近 ts-jest の状況を見てみたら、こんな記述がありました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Starting from v28.0.0, ts-jest will gradually opt in adoption of esbuild/swc more to improve the performance. To make the transition smoothly, we introduce legacy presets as a fallback when the new codes don&amp;rsquo;t work yet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;from https://kulshekhar.github.io/ts-jest/docs/getting-started/presets&lt;/p&gt;

&lt;p&gt;なんと、高速化のために esbuild/swc を使うようになったって。まじかー&lt;/p&gt;

&lt;h3&gt;早速 ts-jest に変えてみた&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@swc-node/jest&lt;/code&gt; から &lt;code&gt;ts-jest&lt;/code&gt; に変更して、 &lt;code&gt;jest.config.js&lt;/code&gt; を &lt;code&gt;preset&lt;/code&gt; に変更。
テストを実行してみると、確かに速くなってる！&lt;/p&gt;

&lt;p&gt;手元のプロジェクトだと、 &lt;code&gt;ts-jest&lt;/code&gt; にかかる時間は、 &lt;code&gt;@swc-node/jest&lt;/code&gt; + &lt;code&gt;tsc&lt;/code&gt; の時間とほぼ一致していました。
&lt;code&gt;ts-jest&lt;/code&gt; ではコンパイルエラーも検知されるので、つまりそういうことでしょう。&lt;/p&gt;

&lt;h3&gt;また ts-jest で大丈夫！&lt;/h3&gt;

&lt;p&gt;ということで、 jest の実行に swc や esbuild を使うことや、tsconfig と違う設定を考慮したりとかなく、TypeScript のコードを jest でテストできるようになりました。&lt;/p&gt;

&lt;p&gt;私たちのプロジェクトは、早速すべて ts-jest@29 に切り替えました。
もし問題がある場合は、 Preset にレガシーモードを指定すると esbuild や swc を使わないようにできるようですが、そもそも一度 swc に切り替えてテストできていれば、問題なく ts-jest に戻れるはずです。&lt;/p&gt;

&lt;p&gt;今後は TypeScript + jest での開発環境に ts-jest のご利用をお勧めします。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>aws-sdk v3 を使うライブラリを作ったときは、なるべく peerDependencies に設定しよう</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/11/aws-sdk-v3-to-peer-for-your-library.html"/>
    <id>http://blog.url.com/2023/04/11/aws-sdk-v3-to-peer-for-your-library.html</id>
    <published>2023-04-11T16:33:00+09:00</published>
    <updated>2023-04-11T17:02:45+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;先日 &lt;a href="/2023/04/06/aws-sdk-v2-will-be-mentenance-mode-in-2023.html"&gt;aws-sdk v2 が 2023 年中にメンテナンスモードになる&lt;/a&gt; という記事を書いて、実際自分たちで作っていた aws-sdk v2 でできていた CLI ツールも aws-sdk v3 に切り替えました。&lt;/p&gt;

&lt;h3&gt;CLIツールを v3 に移行したら、利用するアプリ側がコンパイルエラーになる&lt;/h3&gt;

&lt;p&gt;で、それを Lambda にデプロイするアプリの devDependencies に反映してみたところ、また型エラーが出るようになりました。&lt;/p&gt;

&lt;p&gt;CLIツールでは &lt;code&gt;@aws-sdk/client-lambda@3.310.0&lt;/code&gt; に依存していて、 Lambda アプリ側は &lt;code&gt;@aws-sdk/client-lambda@3.254.0&lt;/code&gt; を使っていたためです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;error TS2345: Argument of type &amp;lsquo;typeof LambdaClient&amp;rsquo; is not assignable to parameter of type &amp;lsquo;InstanceOrClassType&lt;Client&lt;ServiceInputTypes, MetadataBearer, any&gt;&amp;gt;&amp;rsquo;.
      Type &amp;lsquo;typeof LambdaClient&amp;rsquo; is not assignable to type &amp;lsquo;ClassType&lt;Client&lt;ServiceInputTypes, MetadataBearer, any&gt;&amp;gt;&amp;rsquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;で、それぞれの型定義への依存は &lt;code&gt;&amp;quot;@aws-sdk/types&amp;quot;: &amp;quot;*&amp;quot;&lt;/code&gt; になっているので、lock ファイルの状態次第でそれぞれでバージョンが異なるものが入る場合があります。
そこで型が一致しない問題が発生してきます。&lt;/p&gt;

&lt;p&gt;CLI ツールでは実行時に aws-sdk が必要になるので、 dependencies に設定していて、CLIツールを使う方のアプリは devDependencies に設定しているわけですが、それぞれの dependencies からインストールされる &lt;code&gt;@aws-sdk/types&lt;/code&gt; がドッチ？問題になってしまうという&amp;hellip;&lt;/p&gt;

&lt;h3&gt;解決策&lt;/h3&gt;

&lt;p&gt;今回は自分たちで作ったライブラリだったので、CLIツール側の aws-sdk を devDependencies に変更して、CLIツールを使うアプリ側の aws-sdk 利用状況に依存するように変更しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;  &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;peerDependencies&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/client-lambda&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;^3.0.0&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これでアプリ側が &lt;code&gt;@aws-sdk/client-lambda&lt;/code&gt; を使っていればそのバージョンに依存するようになるし、使っていなければ 3系の最新が入るようになります。&lt;/p&gt;

&lt;p&gt;ここで、この aws-sdk v3 シリーズを読んでいただいた懸命な皆様はお気づきだと思いますが &lt;a href="/2023/04/05/aws-sdk-v3-changed-enum-to-const.html"&gt;Node.js v18 / aws-sdk v3 の Lambda アプリが突然動かなくなる&lt;/a&gt; でも書いた&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;peerDependencies&lt;/code&gt; が指定されていたら、バージョンを揃えるために自分でインストールする&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これが重要になってきます。
なので、自分で作ったライブラリで peerDependencies に指定したら、結局アプリ側で使ってなくてもバージョンを揃えるのに追加でインストールした方が良いということです。&lt;/p&gt;

&lt;h3&gt;aws-sdk v3 を安心して使うためには（追記）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;基本的にバージョンは最新版、もしくは最新に近い同じバージョンに揃える&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peerDependencies&lt;/code&gt; が指定されていたら、バージョンを揃えるために自分でインストールする&lt;/li&gt;
&lt;li&gt;関数/クラス以外、たとえば enum の値などは基本的に利用しない&lt;/li&gt;
&lt;li&gt;自作ライブラリで aws-sdk v3 に依存する場合は &lt;code&gt;peerDependencies&lt;/code&gt; に指定する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大事なこと4つ目を追加しました。&lt;/p&gt;

&lt;p&gt;aws-sdk@v3 のパッケージ管理に日々不安が募りますが、同様の問題に遭遇した人の解決に役立てれば幸いです。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>aws-sdk v2 が 2023 年中にメンテナンスモードになる</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/06/aws-sdk-v2-will-be-mentenance-mode-in-2023.html"/>
    <id>http://blog.url.com/2023/04/06/aws-sdk-v2-will-be-mentenance-mode-in-2023.html</id>
    <published>2023-04-06T18:24:00+09:00</published>
    <updated>2023-04-06T18:54:44+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;aws-sdk v2 を使っている CLI ツールで aws 環境を操作していたら、見慣れないメッセージが出てきました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(node:9129) NOTE: The AWS SDK for JavaScript (v2) will be put into maintenance mode in 2023.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AWS SDK v2 ってメンテナンスモードに入るんだ&amp;hellip;&lt;/p&gt;

&lt;p&gt;Twitter でも書いている人がいました&lt;/p&gt;

&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Anyone else seeing this new error from &lt;a href="https://twitter.com/awscloud?ref_src=twsrc%5Etfw"&gt;@awscloud&lt;/a&gt; sdk? &lt;br&gt;&lt;br&gt;This is showing to our CLI users and is&amp;hellip; annoying to say the least. &lt;a href="https://t.co/KabEtFDKnl"&gt;pic.twitter.com/KabEtFDKnl&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Wells (@DavidWells) &lt;a href="https://twitter.com/DavidWells/status/1626321488742862848?ref_src=twsrc%5Etfw"&gt;February 16, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これまでも複数回にわたって aws-sdk v3 の記事を書いてきましたが、これは Lambda にデプロイするアプリだから v3 に移行したのであって、CLIツールとかなら v3 に移行するモチベがあるかな&amp;hellip;.&lt;/p&gt;

&lt;p&gt;ぶっちゃけ Lambda とかだとランタイムに追従すると sdk も上げないといけないので対応したけど、ツールなら対応しないですよね。&lt;/p&gt;

&lt;p&gt;公式のリポジトリにも、サポートについて書かれています。&lt;/p&gt;

&lt;p&gt;https://github.com/aws/aws-sdk-js#version-2x-support&lt;/p&gt;

&lt;p&gt;そこにリンクされている &lt;a href="https://docs.aws.amazon.com/sdkref/latest/guide/maint-policy.html"&gt;メンテナンスポリシーページ&lt;/a&gt; にいくと、以下のような内容が記入されていました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;メンテナンス (フェーズ 3) -メンテナンス モードの間、AWS は SDK リリースを制限して、重大なバグ修正とセキュリティ問題のみに対処します。SDK は、新規または既存のサービスの API 更新を受け取ることも、新しいリージョンをサポートするために更新されることもありません。特に指定がない限り、メンテナンス モードのデフォルト期間は 12 か月です。&lt;/p&gt;

&lt;p&gt;サポート終了 (フェーズ 4) - SDK がサポート終了に達すると、更新またはリリースを受け取ることができなくなります。以前に公開されたリリースは引き続きパブリック パッケージ マネージャーから入手でき、コードは GitHub に残ります。GitHub リポジトリはアーカイブされる場合があります。サポートが終了した SDK の使用は、ユーザーの判断で行われます。ユーザーが新しいメジャー バージョンにアップグレードすることをお勧めします。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;v2 自体がリポジトリから無くなることはなさそうですが、膨大にありそうな v2 を使った CLI ツール群はどうするのかなぁ&amp;hellip;&lt;/p&gt;

&lt;p&gt;ちなみに Serverless Framerwork は PR &lt;a href="https://github.com/serverless/serverless/pull/11769"&gt;Suppress AWS SDK v2 deprecation message&lt;/a&gt; でいったんメッセージ出力を OFF にしていますが、 v3 移行は大変だろうなぁ、という感想しかないです。&lt;/p&gt;

&lt;p&gt;AWS SDK v3 は、これまでの記事でも書いてますが、結構パッケージ管理が残念な感じだったりするのと、書き方もめっちゃ変わっているので Serverless Framework 規模になると書き換えもかなり工数かかりそうだなぁと（いつかはやるんだろうけど）。&lt;/p&gt;

&lt;p&gt;AWS さんが簡易にコンバートできるツールを作ってくれると良いんだろうけど、オプションの書き方も変わっているところがあったりするので、単純な変換も大変そうですね。&lt;/p&gt;

&lt;p&gt;上記の引用ツイートのレスの中にもあるけど、v3 のドキュメントが不親切だというのは事実だし、良い解決策が 2023 年中に見つかると良いですね。
なんか感想ブログになっちゃいましたが、僕らのプロジェクトも v2 依存している CLI ツールは移行対象にしてなかったので、これから移行計画作らないとな、と思っています。&lt;/p&gt;
</content>
  </entry>
</feed>
