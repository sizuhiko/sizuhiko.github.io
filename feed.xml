<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2015-10-03T04:50:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>PHPカンファレンス2015で発表しました</title>
    <link rel="alternate" href="http://blog.url.com/2015/10/03/phpconference-tokyo-2015.html"/>
    <id>http://blog.url.com/2015/10/03/phpconference-tokyo-2015.html</id>
    <published>2015-10-03T04:50:00Z</published>
    <updated>2015-10-05T23:18:15+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;2015/10/03 に行われた&lt;a href="http://phpcon.php.gr.jp/2015/"&gt;PHPカンファレンス2015&lt;/a&gt;で発表をしてきました。&lt;/p&gt;

&lt;p&gt;スライドは以下の内容です。&lt;/p&gt;

&lt;script async class="speakerdeck-embed" data-slide="2" data-id="6747f5a70f5444188f8db70b4492736a" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;

&lt;p&gt;PHPカンファレンスでは公募セッションは最大30分のため、すべてのページについて話すことができませんした。&lt;/p&gt;

&lt;p&gt;セッションはじまるときにComposerの利用状況についてヒアリングしたところ、半数以上の方が「これからComposerを使う人」だったため、
入門部分を中心に解説しました。   &lt;/p&gt;

&lt;p&gt;このブログでは、スライドの共有と共に、話せなかった部分ついて（とうまくいかなかったデモも）書いておきたいと思います。&lt;/p&gt;

&lt;h3&gt;Composerと、その歴史&lt;/h3&gt;

&lt;p&gt;PHPで開発をするのに、デファクトスタンダードになったといって良いComposer。&lt;/p&gt;

&lt;p&gt;Composerは2012年3月1日に生まれました。最初のリリース番号は1.0.0のアルファ1です。
現在も1.0-devというバージョンで日々アップデートが行われています。
2012年というのはすごい最近ですよね。たった3年前です。ではその前はどうだったのか？少しふりかえってみたいと思います。&lt;/p&gt;

&lt;h4&gt;Composerの前はどうだったのか？&lt;/h4&gt;

&lt;p&gt;PHPにはじめて拡張モジュールやライブラリの置き場所ができたのは1999年、pearという名前でした。
perlのCPANに影響を受けていて、あくまでコードリポジトリという位置づけでした。
ComposerがDependency Managementであるのとは異なります。2006年にはPHP5.3に対応したpear2とpyrusが登場しました。
しかしpearは厳密なコードレビューからオープンソースのリポジトリでありながら「誰もが自由に公開できる場所」とはいいづらいものでした。
そこで2008年にnequalが立ち上げたのがopenpearです。pearパッケージを誰もが自由に公開できるような場所となりました。リポジトリはsvnでした。
あのsotarokさんのコメントがトップページにあります「夢のような話だ」、まさにそのとおりでした。しかし時代はgit、githubになり、2012年にcomposerが生まれたのです。&lt;/p&gt;

&lt;h4&gt;Composerを正しく理解する&lt;/h4&gt;

&lt;p&gt;ComposerはDependencyManagementです。
例えばYumやAptといったパッケージ管理とは違います。pearはこちらに近かったかもしれません。
npmやbundlerといったものに影響を受けていて、プロジェクト単位で依存関係を管理します。&lt;/p&gt;

&lt;h4&gt;Composerが必須になる流れ&lt;/h4&gt;

&lt;p&gt;さてpearを使っていた中で、一番インストールしたことがあるパッケージといえば何でしたか？
私はどんなプロジェクトでも必ず必要だったのはPHPUnitではないかと思います。PHPUnitインストールしたことがありますか？
pearでやるとかなり面倒なんですよね、複数バージョン入れ分けなくてはいけないなんて事はなかったですか？（地獄でしたよねw）&lt;/p&gt;

&lt;p&gt;昨年、PHPUnitはPEARから卒業しました。スライドではそのときのSebastionBergmannのツイートを引用しました。
つい最近サルベージしたので、アイコンは当時写真だったと思うのですが、今はイラストですね（良く似ていますww）。&lt;/p&gt;

&lt;p&gt;具体的には、csvから始まって、pearに移って、2009年にはgithubに移って、今日ではpearから卒業する、長らくありがとうという内容です。
PHPUnit3.7.0からComposrで取得可能です。&lt;/p&gt;

&lt;h4&gt;Composerより昔のやり方&lt;/h4&gt;

&lt;p&gt;例えばPHPUnitを例にとって、Composerより前はどんな方法だったか思い出してみましょう。
スライドではPHPUnitのpearを使った導入方法を掲載しました。1つ1つはもう気にしなくて良いのですが、長いですよね。
たいてい秘伝のレシピにしているか、ググってコピペするか、会社でドキュメント化しているか、そんなところだったと思います。&lt;/p&gt;

&lt;p&gt;秘伝のレシピの場合、もちろんコマンド1つかもしれないですが、初めてプロジェクトに入った人がわかるわけではないですね。
複数バージョンを同居させるとかになると、pyrus使ったりしてもう少し違う感じにはなるかと思います。
あと、iniのインクルードパスを設定しないとファイルが読み込めなかったですよね&lt;/p&gt;

&lt;h4&gt;Composerになった（今どきの）やり方&lt;/h4&gt;

&lt;p&gt;Composerになって、初めて入れるときはrequire、他の人はinstallコマンドを実行するだけで良くなりました。
なんて簡単なんだろう、環境設定マニュアルとか必要ないレベルですよね。
composer使ったことあるひとなら、git cloneしたリポジトリにcomposer.jsonがある段階でinstallを実行するはずです。
（phpunitはrequire &amp;ndash;devじゃないとか？いうのはそのとおりですが、今回は省略しています）&lt;/p&gt;

&lt;h3&gt;PHPで正しく開発するには&lt;/h3&gt;

&lt;p&gt;今日ではこのようにPHPでもモダンな開発をするベースが整っています。
PHPでは&lt;a href="http://ja.phptherightway.com"&gt;PHP The Right Way&lt;/a&gt;というページに、そのすべてがまとまっています。
もちろんComposerについても書いてあります。
&lt;code&gt;PHP The Right Way&lt;/code&gt; は PHPerが幸せになる為の道しるべを示してくれています。
もちろん各国の有志によって翻訳されているので、すぐ読めます。かならず読んでみてください。&lt;/p&gt;

&lt;p&gt;スライドの高速道路出口は &lt;a href="http://pro10.sakura.ne.jp/kousoku/"&gt;高速道路風標識ジェネレーター&lt;/a&gt; を使ってみたかっただけで、深い意味はありません。&lt;/p&gt;

&lt;h4&gt;オートローディング&lt;/h4&gt;

&lt;p&gt;PHP The Right Wayではコーディングスタイルや名前空間といったことにも言及しています。
どちらにもPSR-4という記述がありますが、PSR-4はオートロードについての標準です。現在はPSR-0を含んでいるので、PSR-0でなくPSR-4を参照するのが良いでしょう。&lt;/p&gt;

&lt;h4&gt;オートロードとComposerの関係について&lt;/h4&gt;

&lt;p&gt;PHPでクラスをオートロードするには、_&lt;em&gt;autoloadを実装して、クラスが見つからないときに指示してあげるか、spl&lt;/em&gt;autoload_registerで予めクラスのパスを登録しておくという２通りのやり方があります。&lt;/p&gt;

&lt;p&gt;「ちなみにこの方法でオートロードを実装したことがある人はいますか？」という問いにはどなたも手があがりませんでした。これはそのとおりだと思います。Composer以前ではほぼ気にする人はいなかったでしょう。&lt;/p&gt;

&lt;p&gt;もしフレームワークを使ってアプリケーションを実装している人は、フレームワークがオートロードの仕組みを用意してくれていたりするので、より意識しないかなと思います。&lt;/p&gt;

&lt;h3&gt;デモ&lt;/h3&gt;

&lt;p&gt;本番ではうまくいかなかったのですが、こちらで解説します。（カンファレンスあるあるですね）&lt;/p&gt;

&lt;h4&gt;インストール&lt;/h4&gt;

&lt;p&gt;スライドの内容を参考にcomposerをインストールします。
composerはプロジェクトのローカルでなく、パスの通っているところに配置してください。
Right Wayにも書いてあります。
Windowsを利用の方は&lt;a href="https://getcomposer.org/doc/00-intro.md#installation-windows"&gt;公式ドキュメント&lt;/a&gt;を参照ください。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/sizuhiko/phpcon2015_demo"&gt;GitHubのリポジトリ&lt;/a&gt;からソースコードを取得します。&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;git clone git@github.com:sizuhiko/phpcon2015_demo.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;プロジェクト情報の入力&lt;/h4&gt;

&lt;p&gt;まず&lt;code&gt;composer init&lt;/code&gt;コマンドでプロジェクト情報を入力します。
requireやrequire-devは必要ないので、&lt;code&gt;no&lt;/code&gt;を入力すれば大丈夫です。&lt;/p&gt;

&lt;h4&gt;インストールコマンドの実行&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;init&lt;/code&gt;コマンドを実行したら、&lt;code&gt;composer install&lt;/code&gt;コマンドを実行します。最初は何もありません。
&lt;code&gt;vendor&lt;/code&gt;ディレクトリが生成されるはずです。&lt;/p&gt;

&lt;h4&gt;実行してみる&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;php -S localhost:8000 src/router.php&lt;/code&gt; というコマンドを実行します。
ブラウザから&lt;a href="http://localhost:8000"&gt;サンプルページ&lt;/a&gt;を実行してください。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Welcome to PHP&lt;/code&gt; と表示されるはずです。&lt;/p&gt;

&lt;p&gt;次に&lt;code&gt;Say\Hello&lt;/code&gt;クラスを実行してみます。&lt;a href="http://localhost:8000/hello"&gt;/hello&lt;/a&gt;にアクセスします。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Fatal error: Class 'Say\Hello' not found in /phpcon2015_demo/src/router.php on line 19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というエラーが表示されるはずです。
ソースコードでは以下のように指定していますが、オートロードが定義されていないのでクラスは見つかりません。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;use Say\Hello;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、&lt;code&gt;composer.json&lt;/code&gt;を編集して、以下のように&lt;code&gt;require&lt;/code&gt;の下に追記します。&lt;/p&gt;
&lt;pre class="highlight json"&gt;&lt;code&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s2"&gt;"require"&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="s2"&gt;"autoload"&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
        &lt;/span&gt;&lt;span class="nt"&gt;"psr-4"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
            &lt;/span&gt;&lt;span class="nt"&gt;"Say\\"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"src/Say"&lt;/span&gt;&lt;span class="w"&gt;
        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変更を保存したら、&lt;code&gt;composer dumpautoload&lt;/code&gt; というコマンドを実行します。&lt;/p&gt;

&lt;p&gt;再度&lt;code&gt;Say\Hello&lt;/code&gt;クラスを実行してみます。&lt;a href="http://localhost:8000/hello"&gt;/hello&lt;/a&gt;にアクセスします。
すると、ブラウザに&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と表示されるはずです。
今度は&lt;a href="http://localhost:8000/emoji"&gt;/emoji&lt;/a&gt;にアクセスします。
先ほどと同じようなエラーが表示されるので、&lt;code&gt;composer.json&lt;/code&gt;を編集します。&lt;/p&gt;
&lt;pre class="highlight json"&gt;&lt;code&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s2"&gt;"autoload"&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
        &lt;/span&gt;&lt;span class="nt"&gt;"psr-4"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
            &lt;/span&gt;&lt;span class="nt"&gt;"Say\\"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"src/Say"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
            &lt;/span&gt;&lt;span class="nt"&gt;"Write\\"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"src/Write"&lt;/span&gt;&lt;span class="w"&gt;
        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変更を保存したら、&lt;code&gt;composer dumpautoload&lt;/code&gt; というコマンドを実行します。&lt;/p&gt;

&lt;p&gt;再度&lt;code&gt;Write/Emoji&lt;/code&gt;クラスを実行してみます。&lt;a href="http://localhost:8000/emoji"&gt;/emoji&lt;/a&gt;にアクセスします。
すると、ブラウザに&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;(^o^)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と表示されるはずです。&lt;/p&gt;

&lt;p&gt;このようにオートロードについて自分で記述しなくても、名前空間の宣言を&lt;code&gt;composer.json&lt;/code&gt;でおこなうと自動的にクラスをロードしてくれるようになります。&lt;/p&gt;

&lt;h3&gt;More Tips&lt;/h3&gt;

&lt;p&gt;この先は解説できなかった部分なので補足します。&lt;/p&gt;

&lt;h4&gt;リポジトリ管理&lt;/h4&gt;

&lt;p&gt;これについては第94回 PHP勉強会＠東京〜PHPカンファレンス2015開催直前スペシャル〜で話しました。&lt;a href="http://www.s-arcana.co.jp/blog/2015/10/01/2899"&gt;スタジオアルカナのレポート&lt;/a&gt;に詳しいログが残っていますので、そちらを参照ください。&lt;/p&gt;

&lt;h4&gt;スクリプト&lt;/h4&gt;

&lt;p&gt;Composerの強力な機能にスクリプト（フック）の実行があります。
&lt;code&gt;install&lt;/code&gt;や&lt;code&gt;update&lt;/code&gt;など&lt;code&gt;composer&lt;/code&gt;のコマンド実行前と実行後に、スクリプトを実行できます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pre-install-cmd&lt;/li&gt;
&lt;li&gt;post-install-cmd&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のようなイベント名です。
実行できるスクリプトは通常のCLIとPHPのクラスです。&lt;/p&gt;

&lt;p&gt;例えば &lt;code&gt;composer.json&lt;/code&gt; で以下のように記述します。&lt;/p&gt;
&lt;pre class="highlight json"&gt;&lt;code&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s2"&gt;"post-install-cmd"&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt;
        &lt;/span&gt;&lt;span class="s2"&gt;"MyVendor\\MyClass::warmCache"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
        &lt;/span&gt;&lt;span class="s2"&gt;"phpunit -c app/"&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;より詳しい情報は&lt;a href="https://getcomposer.org/doc/articles/scripts.md"&gt;公式サイト&lt;/a&gt;を参照して欲しいのですが、これの使い方は２つ考えられます。&lt;/p&gt;

&lt;p&gt;１つ目は、すでに存在するライブラリに対するプロキシとしたい場合です。
公開されているライブラリをForkしたり、コピーしてくることなく、独自の変更を加えたい場合や、ライブラリをインストールした後で独自のconfigを追加したい場合など、社内で複数のプロジェクトにまたがって同じカスタマイズをしたい場合は有効です。それぞれのプロジェクトではプロキシした&lt;code&gt;composer.json&lt;/code&gt;のあるリポジトリを指定するだけで、元のライブラリを修正することなく、同じようにカスタマイズ状態を利用できます。&lt;/p&gt;

&lt;p&gt;２つ目は、フレームワークやライブラリを作った場合です。現在多くのフレームワークはアプリケーションテンプレートとして、&lt;code&gt;composer create-project&lt;/code&gt;に対応したスケルトンを用意しています。何もなければそれを取得すれば良いのですが、もちろん&lt;code&gt;create-project&lt;/code&gt;コマンドにもフックポイントが用意されているので、&lt;code&gt;install&lt;/code&gt;後には環境設定ファイルなどがコピーされるようになっています。&lt;/p&gt;

&lt;h3&gt;まとめ&lt;/h3&gt;

&lt;p&gt;このようにComposerはpearでできていたパッケージ（コードリポジトリ）管理から、より多くの機能を持って、現在のアプリケーション開発になくてはならないものとなっています。&lt;/p&gt;

&lt;p&gt;このセッションでComposerを使うようになってくれる人が増えることを期待してまとめとしたいと思います。&lt;/p&gt;

&lt;h3&gt;おまけ&lt;/h3&gt;

&lt;p&gt;LTのスライドも公開します。&lt;/p&gt;

&lt;script async class="speakerdeck-embed" data-slide="2" data-id="3eea01f6480c4c5996cc0c988435a63a" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
</content>
  </entry>
  <entry>
    <title>複雑な正規表現を簡単に作れるようにした</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/21/hexpress-ported-from-ruby-world.html"/>
    <id>http://blog.url.com/2015/09/21/hexpress-ported-from-ruby-world.html</id>
    <published>2015-09-21T04:28:00Z</published>
    <updated>2015-09-21T14:03:55+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;この記事は先日の&lt;a href="/2015/09/13/verbal-expression-php.html"&gt;正規表現を簡単に作るには&lt;/a&gt;の続編になります。&lt;/p&gt;

&lt;p&gt;前回、RFC3986のような複雑な正規表現をVerbal Expressionの既存実装でやろうとすると、うまくできないという問題に直面しました。
そこでRubyで実装されていた&lt;a href="http://www.kurtisrainboltgreene.name/hexpress/"&gt;HEXPRESS&lt;/a&gt;をPHPへ移植しようという流れです。&lt;/p&gt;

&lt;h3&gt;PHP版Hexpressを作った&lt;/h3&gt;

&lt;p&gt;さっそく移植してみました。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/sizuhiko/hexpress"&gt;hexpress&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PSR-2の対応が実施中なのですが、Ruby側の機能とテストはすべて移植し、PHP版でいくつか機能追加をしています。&lt;/p&gt;

&lt;h3&gt;どんな感じか&lt;/h3&gt;

&lt;p&gt;READMEに書いてあるとおりインストールはcomposer経由でできます。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;composer require sizuhiko/hexpress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的な利用方法は以下のサンプルのとおりです。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;use Hexpress\Hexpress;

$pattern = (new Hexpress())
    -&amp;gt;start("http")
    -&amp;gt;maybe("s")
    -&amp;gt;with("://")
    -&amp;gt;maybe(function($hex) { $hex-&amp;gt;words()-&amp;gt;with("."); })
    -&amp;gt;find(function($hex) { $hex-&amp;gt;matching(function($hex) {$hex-&amp;gt;word()-&amp;gt;with("-");})-&amp;gt;many(); })
    -&amp;gt;has(".")
    -&amp;gt;either(["com", "org"])
    -&amp;gt;maybe("/")
    -&amp;gt;ending();

echo $pattern;             #=&amp;gt; "^https?\:\/\/(?:(?:\w)+\.)?([\w\-]+)\.(?:com|org)\/?$"
echo $pattern-&amp;gt;toRegExp(); #=&amp;gt; "/^https?\:\/\/(?:(?:\w)+\.)?([\w\-]+)\.(?:com|org)\/?$/"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Hexpress&lt;/code&gt;クラスのインスタンスを生成して、メソッドチェインで正規表現を組み立てます。
ネストしたい場合は、コールバック関数を指定すると、新しい&lt;code&gt;Hexpress&lt;/code&gt;のインスタンスがパラメータで渡ってくるので、
それに対してメソッドチェインでつないていきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hexpress&lt;/code&gt;は&lt;code&gt;__toString()&lt;/code&gt;を実装しており、文字列表現を取得すると指定された定義を展開します。
実際に正規表現として利用するには&lt;code&gt;toRegExp()&lt;/code&gt;を呼び出すと、左右にデリミタを挿入した文字列が取得できるので、&lt;code&gt;preg_match&lt;/code&gt;などの関数で利用可能になります。
例えば以下のような利用方法です。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;preg_match("http://example.com/", $pattern-&amp;gt;toRegExp());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;複雑な正規表現は定義できたのか？&lt;/h3&gt;

&lt;p&gt;できました！！&lt;/p&gt;

&lt;p&gt;テストコードとして&lt;a href="https://github.com/sizuhiko/hexpress/blob/master/tests/Case/Hexpress/RFC3986Test.php"&gt;RFC3986Test.php&lt;/a&gt;を作成しました。
実装は結構長いので、こちらに添付することは省略しますが、RFCの定義に書いてあるとおりそのままメソッドをつないでいくだけで、
RFCに対応した正規表現を構築することができました。（※IPv6の定義は未実装です、ご了承ください）&lt;/p&gt;

&lt;p&gt;PHPUnitのデータプロバイダ&lt;code&gt;exampleUriProvider&lt;/code&gt;でマッチさせるパターンをftp,www,mail,news,tel,telnet,urnについて定義してすべて通過しています。&lt;/p&gt;

&lt;p&gt;PHP版では、マッチするとき&lt;code&gt;find&lt;/code&gt;メソッドで名前付きサブパターンを利用できるようにしました。
以下の例のように、&lt;code&gt;find&lt;/code&gt;の第二引数に&lt;code&gt;port&lt;/code&gt;を指定できます。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;    private function port()
    {
        return (new Hexpress())-&amp;gt;has(':')-&amp;gt;find(function ($hex) { $hex-&amp;gt;digits(); }, 'port');
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記を含むパターンを&lt;code&gt;preg_match&lt;/code&gt;で処理すると、マッチング結果に名前付きで値を取得できるようになります。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;preg_match("http://example.com:80/", $pattern-&amp;gt;toRegExp(), $matches);
echo $matches['port'];   #=&amp;gt; '80'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;どうなのか？&lt;/h3&gt;

&lt;p&gt;たとえば今回作成したRFC3986の定義を正規表現としてダンプすると、以下のようになります。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;/^(?P&amp;lt;scheme&amp;gt;[a-zA-Z](?:[a-zA-Z0-9\+\-\.])*)\:(?P&amp;lt;hierPart&amp;gt;(?:\/\/(?P&amp;lt;authority&amp;gt;(?:(?P&amp;lt;userinfo&amp;gt;(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:))*)@)?(?P&amp;lt;host&amp;gt;(?:(?:0-9|1-90-9|10-90-9|20-40-9|250-5)\.(?:0-9|1-90-9|10-90-9|20-40-9|250-5)\.(?:0-9|1-90-9|10-90-9|20-40-9|250-5)\.(?:0-9|1-90-9|10-90-9|20-40-9|250-5)|(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]))+))(?:\:(?P&amp;lt;port&amp;gt;(?:\d)+))?)(?P&amp;lt;pathAbempty&amp;gt;(?:\/(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@))*)*)|(?P&amp;lt;pathAbsolute&amp;gt;\/(?:(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@))+(?:\/(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@))*)+)?)|(?P&amp;lt;pathRootless&amp;gt;(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@))+(?:\/(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@))*)*)|(?P&amp;lt;pathEmpty&amp;gt;^(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@))))(?:\?(?P&amp;lt;query&amp;gt;(?:(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@)|\/|\?))*))?(?:#(?P&amp;lt;fragment&amp;gt;(?:(?:(?:[a-zA-Z0-9\-\._~]|%(?:[0-9A-Z]){2}|[\!\$&amp;amp;'\(\)\*\+,;\=]|\:|@)|\/|\?))*))?$/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私はいきなりこれを空手形で実装することはできそうにないので、今回&lt;code&gt;hexpress&lt;/code&gt;を移植して良かったなと思っています。
何か複雑な正規表現を定義したい場合などに役立てば幸いです。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://phpcon.php.gr.jp/2015/"&gt;日本PHPカンファレンス2015&lt;/a&gt;が10/3(土)に行われます。
当日のプログラムも公開され、私はトラック3で10:50から11:20まで「Composerではじめるアプリケーション開発」というセッションを担当します。
他の番組が強力なため私の会場は比較的空いているのではないかと思うので、もしご都合がつく方はよろしくお願いします。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>正規表現を簡単に作るには</title>
    <link rel="alternate" href="http://blog.url.com/2015/09/13/verbal-expression-php.html"/>
    <id>http://blog.url.com/2015/09/13/verbal-expression-php.html</id>
    <published>2015-09-13T07:11:00Z</published>
    <updated>2015-09-13T16:57:18+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;皆さんは正規表現好きですか？そして得意ですか？
私は好きですが、得意とは言えません。&lt;/p&gt;

&lt;h3&gt;VerbalExpressionという選択肢&lt;/h3&gt;

&lt;p&gt;そこでVervalExpressionという正規表現を簡単に組むことができる仕組みがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://verbalexpressions.github.io/"&gt;http://verbalexpressions.github.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サイトに「Regular Expressions made easy」と書いてあるように、簡単に正規表現が作れることを表明しています。
様々な言語にポートされていますが、もちろんPHP版もあります。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/VerbalExpressions/PHPVerbalExpressions"&gt;https://github.com/VerbalExpressions/PHPVerbalExpressions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サイトのサンプルにも書いてあるとおり、以下のようなURLにマッチする正規表現が記述できます。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;use VerbalExpressions\PHPVerbalExpressions\VerbalExpressions;

$regex = new VerbalExpressions;
$regex  -&amp;gt;startOfLine()
        -&amp;gt;then("http")
        -&amp;gt;maybe("s")
        -&amp;gt;then("://")
        -&amp;gt;maybe("www.")
        -&amp;gt;anythingBut(" ")
        -&amp;gt;endOfLine();

echo $regex-&amp;gt;getRegex() ."\n";
if (preg_match($regex, 'http://github.com')) {
    echo "valid url\n";
} else {
    echo "invalud url\n";
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つ目のechoの結果は &lt;code&gt;/^(?:http)(?:s)?(?:\:\/\/)(?:www\.)?(?:[^ ]*)$/m&lt;/code&gt; で、2つ目のechoは &lt;code&gt;valid url&lt;/code&gt; を表示します。
VerbalExpressionsクラスに &lt;code&gt;toString&lt;/code&gt; メソッドが実装されているので、 &lt;code&gt;preg_match&lt;/code&gt; 関数でそのまま使えます。&lt;/p&gt;

&lt;h3&gt;複雑なことはできるか？&lt;/h3&gt;

&lt;p&gt;例えばRFC3986に書いてあるURLパターンをマッチさせようとすると、どうなるでしょうか？
一旦スキーマ部分だけ記述してみます。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;$rfc3986 = new VerbalExpressions;
// scheme
$scheme = new VerbalExpressions;
$scheme-&amp;gt;add("http")-&amp;gt;maybe("s")-&amp;gt;_or("ftp");

$rfc3986-&amp;gt;startOfLine()
        -&amp;gt;add($scheme)
        -&amp;gt;add("://");
echo $rfc3986-&amp;gt;getRegex() ."\n";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は &lt;code&gt;/^(?:\(\?\:http\)\(\?\:s\)\?\)\|\(\?\:ftp)(?:\:\/\/)/m&lt;/code&gt; のようになってしまい、期待通りではありません。
この実装は入れ子には対応していないようです。&lt;/p&gt;

&lt;h3&gt;もう１つのVerbalExpression実装&lt;/h3&gt;

&lt;p&gt;PHPにはもう１つ別のVerbalExpression実装があります。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/markwilson/VerbalExpressionsPhp"&gt;https://github.com/markwilson/VerbalExpressionsPhp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こちらの実装はREADMEに入れ子について記述されているように、入れ子の対応はされているようです。
では早速RFC3986の定義を試してみましょう。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;$rfc3986 = new VerbalExpression;
// scheme
$scheme = new VerbalExpression;
$scheme-&amp;gt;then("http", false)-&amp;gt;maybe("s", false)-&amp;gt;orPipe("ftp", false);

$rfc3986-&amp;gt;startOfLine()
        -&amp;gt;find($scheme)
        -&amp;gt;find("://")
        -&amp;gt;endOfLine();
echo $rfc3986-&amp;gt;compile() ."\n";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は &lt;code&gt;^((?:http)(?:s)?()|()(ftp))(\:\/\/)$&lt;/code&gt; のようになってしまい、まぁ不正ではないのですが、かなり無駄があります。&lt;/p&gt;

&lt;h3&gt;現時点結局のところ&lt;/h3&gt;

&lt;p&gt;どちらの実装も簡単なパターンをやるときには良いのですが、ちょっと複雑なパターンを実装しようと思うと微妙です。
大体、簡単なパターンはそのまま正規表現書けば良いじゃん&amp;hellip; という話ですしね。&lt;/p&gt;

&lt;h3&gt;目指したいところ&lt;/h3&gt;

&lt;p&gt;RubyのVerbalExpressions実装には &lt;a href="http://www.kurtisrainboltgreene.name/hexpress/"&gt;HEXPRESS&lt;/a&gt; があります。
これはVerbalExpressionsよりさらに便利なヘルパーを備えて &lt;code&gt;Human Expressions, a human way to define regular expressions&lt;/code&gt; という標語のとおりより簡単に実装できるように見えます。&lt;/p&gt;

&lt;p&gt;これをPHPに移植して使えるようにしようというのが、直近やろうとしていることです。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://phpcon.php.gr.jp/2015/"&gt;日本PHPカンファレンス2015&lt;/a&gt;が10/3(土)に行われます。
私もスピーカーとして登壇しますので、もしご都合がつく方はよろしくお願いします。   &lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>htmldayのイベントに参加してきた</title>
    <link rel="alternate" href="http://blog.url.com/2015/06/14/htmlday-2015.html"/>
    <id>http://blog.url.com/2015/06/14/htmlday-2015.html</id>
    <published>2015-06-14T09:33:00Z</published>
    <updated>2015-06-14T19:34:21+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="/images/blog/htmlday2015.jpg" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;htmldayとは、日本全国でWebに関する多数のイベントを同じ日（6/13）に開催することで、日本のWebを一層盛り上げようという「お祭り」です。（毎年6月の第2土曜日に開催しています。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ということで、以下のイベントに参加してきました。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/htmlday2015-events.png" /&gt;&lt;/p&gt;

&lt;h3&gt;当日の講演資料&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://dackdive.hateblo.jp/entry/2015/06/13/161143"&gt;まとめサイト&lt;/a&gt; ができました。ありがたやー。&lt;/p&gt;

&lt;h3&gt;サービスワーカーが今後のフロントエンドを支える&lt;/h3&gt;

&lt;p&gt;Google I/Oからの流れもあると思うのですが、サービスワーカー(ServiceWorker)に関連する発表が3連続になったりと、これから取り組まないといけない技術だと思います。
SafariとIEのサポートがまだなのですが、IEに関してはEdgeがChrome相当なので、MSではそちらに期待し、Appleはそのうち対応してくれるのではないかと期待しています。&lt;/p&gt;

&lt;p&gt;サービスワーカーとはブラウザにインストールできるタスクで、アプリケーションのバックグラウンドで動作するもので、例えばPush通知とかキャッシュとかオフラインモードの実装なんかをするのに、とても役立つ技術です。&lt;/p&gt;

&lt;p&gt;サービスワーカーに関しての詳しい内容はググるとたくさん出てくるので、それらを参照してください。&lt;/p&gt;

&lt;h3&gt;気になるキーワード&lt;/h3&gt;

&lt;p&gt;発表の中で気になったキーワードと、関連URLを紹介します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.html5rocks.com/ja/tutorials/service-worker/introduction/"&gt;Cache API&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;サービスワーカーの紹介記事の中で「Service Worker のインストール」以降にキャッシュを使う例が出ています&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch"&gt;Fetch API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.w3.org/TR/push-api"&gt;Push API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/google/lovefield"&gt;Lovefield&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Indexed Databaseに対してSQLライクにアクセスできるようにしたライブラリ、Googleが開発した&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://babeljs.io/"&gt;Babel&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ES6のコードをES5形式にコンパイルしてクロスブラウザで動作できるようにする&lt;/li&gt;
&lt;li&gt;gulpとの相性が良いので便利&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vorlonjs.com/"&gt;VORLON.JS&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザをリモートでバッグするツール。マイクロソフトが開発している&lt;/li&gt;
&lt;li&gt;スマートフォンのエミュレータを使ったときDOMやJavaScriptのデバッグが難しいが、それをリモートデバッグできるようにする（昔も似た技術はあった気がする）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.manifoldjs.com/"&gt;manifoldjs&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;HTML5アプリケーションを各プラットフォーム用のアプリケーションに変換するツール&lt;/li&gt;
&lt;li&gt;Windowsストアアプリ、Androidアプリ、iOSアプリ、Chromeアプリ、FirefoxOSアプリに変換できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Polymer1.0がキタ&lt;/h3&gt;

&lt;p&gt;そしてPolymerな訳です。私はPolymer大好きで0.5をけっこう弄っていたのですが、1.0は互換性ないということで、個人的な利用にとどめておいて良かったと思っています。&lt;/p&gt;

&lt;p&gt;PolymerはWebコンポーネントを実装するための仕組みにフォーカスしているので、いわゆるMVCフレームワークとは違います。
今流行のReact.jsとはかぶる部分が多いと思っています。&lt;/p&gt;

&lt;p&gt;Polymerが適用されている実例としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Atavist&lt;/li&gt;
&lt;li&gt;salesforce&lt;/li&gt;
&lt;li&gt;vaadin&lt;/li&gt;
&lt;li&gt;youtube&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして今回のGoogle I/Oサイトということだそうです。&lt;/p&gt;

&lt;p&gt;で、Polymerを簡単に始めるためには&lt;a href="https://developers.google.com/web/tools/polymer-starter-kit/"&gt;Polymer Starter Kit&lt;/a&gt;というものがあります。
これを使うと、ブラウザで簡単にPolymerを使ったサイトのディレクトリ構成やファイルの配置、gulpのビルドファイルなどを初期構築できます。
Yeoman的な役割ですね。&lt;/p&gt;

&lt;p&gt;Googleが提唱する&lt;a href="http://www.google.com/design/spec/material-design/introduction.html#"&gt;Material design&lt;/a&gt;をベースにPolymerでサイトを作ると、あらゆるデバイスに最適なGoogle I/Oのようなサイトを作れるので、サイトを例としてPolymerを使ってみるのが良さそうです。&lt;/p&gt;

&lt;p&gt;Polymerの注意点としては、ShadowDOMの実装がアレということで、Polymer1.0ではShady DOMという疑似ShadowDOMを実装しています。ShadowDOMと思ってるとそうではないのです。&lt;/p&gt;

&lt;h3&gt;最後に&lt;/h3&gt;

&lt;p&gt;ServiceWorker、ES6、Polymerあたりの技術は今後重要になってくると思っているので、何か作りたいなーと思う収穫多きイベントでした。&lt;/p&gt;

&lt;p&gt;あと懇親会が2度（イベントが午後の部と、夜の部にわかれていたので）あって、おいしいお酒とたくさんのビールに囲まれて幸せでした。
スポンサー様、協賛ありがとうございました！&lt;/p&gt;

&lt;p&gt;htmlday 2015 のイベントTシャツをジャンケン大会、最後の最後、ほんとの最後の1枚でGETしました！ありがたやー。早速着てこのBlogを書いています。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>CakeFest2015に参加してきた</title>
    <link rel="alternate" href="http://blog.url.com/2015/06/14/cakefest2015.html"/>
    <id>http://blog.url.com/2015/06/14/cakefest2015.html</id>
    <published>2015-06-14T04:44:00Z</published>
    <updated>2015-06-14T15:29:38+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="/images/blog/cakefest2015.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;今年はCakePHP生誕10周年ということもあり、かねてよりアニバーサリーCakeFestとも言われていました。&lt;/p&gt;

&lt;p&gt;開催場所は世界一の都市ニューヨークです。
私個人でも初のニューヨークです。&lt;/p&gt;

&lt;h3&gt;今年の第一印象&lt;/h3&gt;

&lt;p&gt;初参加が多い。CakeFestでは毎年会う馴染みの人もいるのですが、今年は特に初参加が多かったようです。
参加者が多い。さすが10周年というべきか、ニューヨークなのでアメリカの人が多かったようです。&lt;/p&gt;

&lt;h3&gt;印象に残ったセッション&lt;/h3&gt;

&lt;p&gt;昨年までと同様に、CakePHPに関する主なセッションはコアチームから、その他Webに関するトピックをCFPで通ったスピーカーからという流れでした。
今年はコミュニティマネージャのJamesが急に来れなくなってしまい、イベントの仕切りに不安を覚えるスタートだったのですが、Larryが八面六臂の働きで素晴らしいCakeFestになりました。LarryがLTのタイムキーパーやったり、抽選会の司会やったり、それはそれは大活躍でした。&lt;/p&gt;

&lt;p&gt;コアチームの中でも&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mark Storyのセッション &lt;a href="http://www.slideshare.net/markstory/cakephp-30-and-beyond"&gt;CakePHP 3.0.0 and beyond (Conference)&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Jose Lorenzo Rodriguezのセッション &lt;a href="http://www.slideshare.net/josezap1/agile-database-access"&gt;Agile Database Access with CakePHP 3 (Conference)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;についてはCakePHPを利用する人には一読を薦める内容です。&lt;/p&gt;

&lt;h4&gt;Mark Storyのセッション&lt;/h4&gt;

&lt;p&gt;とは言えMarkのスライドはいつもの通りお題しか書いていないので、少し詳細にふれておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CakePHP3の開発期間3年はとても長かった&lt;/li&gt;
&lt;li&gt;周辺の変化

&lt;ul&gt;
&lt;li&gt;PHPのバージョンも変わったし、機能も変わった

&lt;ul&gt;
&lt;li&gt;3年前のPHPは5.4.4(Released: 14 June 2012)あたりです。&lt;/li&gt;
&lt;li&gt;現在は5.6.9で、その間にはジェネレータや可変引数などが導入されました。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;他のフレームワークの流れも変わった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CakePHP3は2ヶ月で8万ダウンロードされた。すごいね。&lt;/li&gt;
&lt;li&gt;今後のバージョンの話（詳しくは&lt;a href="https://github.com/cakephp/cakephp/wiki"&gt;githubのロードマップ&lt;/a&gt;を見てね）

&lt;ul&gt;
&lt;li&gt;PSR-7対応は3.2の予定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大きく変わったところ

&lt;ul&gt;
&lt;li&gt;Mailers：メール送信がこれまでよりも簡単になる&lt;/li&gt;
&lt;li&gt;CLI：出力フォーマットの機能が増える。例えばプログレスバーとか簡単に出せるようになる&lt;/li&gt;
&lt;li&gt;ORM：Joseが明日話すけど、関連のロードとかマッチングクエリが書けるようになるよ&lt;/li&gt;
&lt;li&gt;ElasticSearch：ORMと似た呼び出し方法が使えるようになる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;今後注力していくところ

&lt;ul&gt;
&lt;li&gt;プラグインのリリース&lt;/li&gt;
&lt;li&gt;3.x系の開発

&lt;ul&gt;
&lt;li&gt;これにより2系については3からのバックポートが中心となる&lt;/li&gt;
&lt;li&gt;3.x内での互換性は重視している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PHP7&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Jose Lorenzo Rodriguezのセッション&lt;/h4&gt;

&lt;p&gt;Joseのセッションはコード多めで、解説だけではわかりづらいと思うのでサンプルコードが提供されています。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/lorenzo/cakephp3-advanced-examples"&gt;サンプルコード::github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;スライドの最初に出てくる3つのタイプのORM&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;いらっとする&lt;/li&gt;
&lt;li&gt;おもちゃみたいな&lt;/li&gt;
&lt;li&gt;流行の（通の）&lt;/li&gt;
&lt;li&gt;すばらしい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もちろんCakePHP3のORMは&lt;code&gt;すばらしい&lt;/code&gt;ものだよ。という流れで掴みはOKな展開。ちなみにQ&amp;amp;AでDoctrineは？という質問に「Hipster」と即座に回答していました。
ちなみに日本だとAgileはアジャイルと発音するけど、Joseのセッションではずっとエイジールと聞こえていた。&lt;/p&gt;

&lt;p&gt;スライドやサンプルを見てもらえると、CakePHP3のORMがかなり強力になっているのがわかると思います。
特に気になったのは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;タイプヒント&lt;/li&gt;
&lt;li&gt;カスタムファインダー&lt;/li&gt;
&lt;li&gt;集合検索&lt;/li&gt;
&lt;li&gt;多重階層の集合検索&lt;/li&gt;
&lt;li&gt;他のDBへのアソシエーション定義&lt;/li&gt;
&lt;li&gt;バーチャルフィールド&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あたりです。サンプルを使って実際に動かしてみるのが良いですね。まだ全部試せていないけど、CakePHP3もくもく会で少しずつ試せたら良いなーと思っています。&lt;/p&gt;

&lt;h3&gt;10周年&lt;/h3&gt;

&lt;p&gt;ノベルティが久々にたくさんあった。きっとシカゴ以来。&lt;/p&gt;

&lt;blockquote class="twitter-tweet" lang="ja"&gt;&lt;p lang="tl" dir="ltr"&gt;Swag at &lt;a href="https://twitter.com/hashtag/CakeFest2015?src=hash"&gt;#CakeFest2015&lt;/a&gt; &lt;a href="http://t.co/gVbDL5ctPl"&gt;pic.twitter.com/gVbDL5ctPl&lt;/a&gt;&lt;/p&gt;&amp;mdash; CakePHP (@cakephp) &lt;a href="https://twitter.com/cakephp/status/604985701025869824"&gt;2015, 5月 31&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;で、私はそのシカゴから参加して6回目の参加となりました。
最後の抽選会でシカゴに参加した人、というときに私含め3人しか立たなかった（コアチームは除く）。さらにそのうち1人はマリアーノです。&lt;/p&gt;

&lt;p&gt;アニバーサリーということで最後の目玉商品は来年のCakeFest招待券！！。なんと交通費込み（上限あるけど）。
当選者は&lt;/p&gt;

&lt;blockquote class="twitter-tweet" lang="ja"&gt;&lt;p lang="en" dir="ltr"&gt;The winners of free tickets to &lt;a href="https://twitter.com/hashtag/CakeFest2016?src=hash"&gt;#CakeFest2016&lt;/a&gt; &lt;a href="http://t.co/FvB3olZCgN"&gt;pic.twitter.com/FvB3olZCgN&lt;/a&gt;&lt;/p&gt;&amp;mdash; CakePHP (@cakephp) &lt;a href="https://twitter.com/cakephp/status/605408000073965568"&gt;2015, 6月 1&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;p&gt;奥山さん！！！、来年はVIP待遇ですなー。来年はドイツらしいですよ。&lt;/p&gt;

&lt;h3&gt;感謝&lt;/h3&gt;

&lt;p&gt;10周年ということで、ここ数年は安藤さんと私の2人だったのを、もっと多くのCakePHPユーザにCakeFestに参加して欲しいと思い、様々なところでくどいぐらい誘いました（ご迷惑だった皆様すみません）。結果、私含め5人が日本から参加ということで、とても楽しかったです。&lt;/p&gt;

&lt;p&gt;安藤さんの紹介で、pivotal lab.にも訪問できたし、ピザ屋さんも（すごい）美味しかったです。&lt;/p&gt;

&lt;p&gt;また、日本でCakeRadioGaGaの中継を受け取ってくれたCo-Edoの田中さん、中継を見てくれた皆様、ありがとうございました。
別途報告会（もくもく会の中で？）、できたら良いなーと思っています。&lt;/p&gt;

&lt;p&gt;そのほかGoogle社の前で写真撮ったり、チェルシーマーケットでおみやげ買ったり、MOMA行ったり、ちゃんとニューヨークも楽しむことができました。&lt;/p&gt;

&lt;p&gt;最後に、CakeRadioGaGaの中継動画を。そういえばMarkとJoseに今年もメッセージちょうだいと言っていたのに、すっかり忘れたのは内緒です&amp;hellip;&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/VSwEo9VIi2A" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
</content>
  </entry>
  <entry>
    <title>CakePHP3 のアプリケーションを Behat でテストする</title>
    <link rel="alternate" href="http://blog.url.com/2015/05/17/cakephp3-behat.html"/>
    <id>http://blog.url.com/2015/05/17/cakephp3-behat.html</id>
    <published>2015-05-17T08:21:00Z</published>
    <updated>2015-05-17T19:08:06+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img src="/images/blog/cakephp3_behat.png" /&gt;&lt;/p&gt;

&lt;p&gt;CakePHP3の変更点として大きく取り上げられるのが、モデル層の変更でしょう。
しかしそれ以上に私たちが受けられる恩恵で大きいのが、PSR-2の採択です。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://bakery.cakephp.org/2014/12/16/CakePHP-3-to-fully-adopt-PSR-2.html"&gt;CakePHP3 is fully adopt PSR-2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えばCakePHP2で単体テストを実行するときは、以下のように&lt;code&gt;cake&lt;/code&gt;コマンドを使って実行する必要がありました。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Console/cake test app Model/Articles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cakeコマンド内でPHPUnitへの依存関係を解決し、PHPUnitからCakePHPのクラスが参照可能になるように作られていました。&lt;/p&gt;

&lt;p&gt;ところがCakePHP3からは、以下のように&lt;code&gt;phpunit&lt;/code&gt;コマンドを使って実行します。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;vendor/bin/phpunit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PSR-0のオートロードに対応したことで、PHPUnitからCakePHP3のクラスが参照可能になるのです。&lt;/p&gt;

&lt;h3&gt;はじめてみよう&lt;/h3&gt;

&lt;p&gt;同様の理由で、CakePHP2のアプリケーションをBehatでテストしたい場合は、私が作成した&lt;a href="https://github.com/sizuhiko/Bdd"&gt;Bdd Plugin&lt;/a&gt;を使ってBehatのステップ記述からCakePHPのクラスを参照可能になるようにしていました。&lt;/p&gt;

&lt;p&gt;しかしBehatにおいても直接実行したステップ定義から、CakePHP3のクラスが参照可能になるのです。&lt;/p&gt;

&lt;p&gt;CakePHP3のアプリケーションをどのようにBehatからアクセスするのか、CakePHP3のブログチュートリアルを例にサンプルアプリを作成しました。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/sizuhiko/cakephp3-bdd-example"&gt;cakephp3-bdd-example&lt;/a&gt;    &lt;/p&gt;

&lt;p&gt;サンプルアプリケーションは&lt;a href="/2015/04/19/cakebox-is-awesome.html"&gt;以前記事&lt;/a&gt;にもした&lt;a href="https://github.com/alt3/cakebox"&gt;Cakebox&lt;/a&gt;を使って構築しました。
またサンプルアプリケーションの実行にもCakeboxを使うと簡単に実行環境を構築することができます。&lt;/p&gt;

&lt;p&gt;サンプルアプリケーションのGithubページに書いてあるとおりの手順で進むことができます。
本ブログでは日本語で補足します。&lt;/p&gt;

&lt;h4&gt;必要なアプリケーションのインストール&lt;/h4&gt;

&lt;p&gt;以下のアプリケーションをホストOSにインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VirtualBox&lt;/li&gt;
&lt;li&gt;Vagrant&lt;/li&gt;
&lt;li&gt;Cakebox&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは&lt;a href="/2015/04/19/cakebox-is-awesome.html"&gt;Cakebox を使ってCakePHP3アプリケーションを作ってみよう&lt;/a&gt;の記事を参照してください。&lt;/p&gt;

&lt;h4&gt;サンプルアプリケーションのインストール&lt;/h4&gt;

&lt;p&gt;CakeboxのゲストOSにログインして、cakeboxコマンドでアプリケーションをインストールします。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;localhost:cakebox $ vagrant ssh
Welcome to Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-24-generic x86_64)

vagrant@cakebox $ cakebox application add blog-tutorial.app --source https://github.com/sizuhiko/cakephp3-bdd-example.git --webroot blog-tutorial.app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、以下のように表示されます。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Creating application http://blog-tutorial.app

Configuring installer
Creating installation directory
Git installing user specified application sources
Creating virtual host
* Successfully created PHP-FPM virtual host
Creating databases
* Successfully created main database
* Successfully created test database
Configuring permissions
Updating configuration files
Application created using:
  database =&amp;gt; blog-tutorial_app
  framework_human =&amp;gt; user specified
  framework_short =&amp;gt; custom
  installation_method =&amp;gt; git
  path =&amp;gt; /home/vagrant/Apps/blog-tutorial.app
  source =&amp;gt; https://github.com/sizuhiko/cakephp3-bdd-example.git
  url =&amp;gt; blog-tutorial.app
  webroot =&amp;gt; blog-tutorial.app
Please note:
  =&amp;gt; Configuration files are not automatically updated for user specified applications.
  =&amp;gt; Make sure to manually update your database credentials, plugins, etc.

Remember to update your hosts file with: 10.33.10.10 http://blog-tutorial.app

Installation completed successfully
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新規アプリケーションの構築と同じように、データベースやNginxの設定ファイルも生成してくれるので、すぐにアプリケーションを実行できる環境が整います。&lt;/p&gt;

&lt;p&gt;あとはアプリケーションのルートディレクトリに移動して、不足しているディレクトリを作ってcomposerでライブラリをインストールします。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;vagrant@cakebox $ cd Apps/blog-tutorial.app
vagrant@cakebox:~/Apps/blog-tutorial.app$ mkdir tmp 
vagrant@cakebox:~/Apps/blog-tutorial.app$ mkdir logs
vagrant@cakebox:~/Apps/blog-tutorial.app$ cp config/app.default.php config/app.php
vagrant@cakebox:~/Apps/blog-tutorial.app$ composer install 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;サンプルアプリケーションの環境設定&lt;/h4&gt;

&lt;h5&gt;データベース接続設定の変更&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;config/app.php&lt;/code&gt;のデータベース接続設定をCakeboxで生成された内容に変更します。
以下のとおり&lt;code&gt;username&lt;/code&gt;と&lt;code&gt;database&lt;/code&gt;の部分のみ変更します（それ以外はそのまま）。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;    'Datasources' =&amp;gt; [
        'default' =&amp;gt; [
            // 省略
            'username' =&amp;gt; 'cakebox',
            'database' =&amp;gt; 'blog-tutorial_app',
            // 省略
        ],
        'test' =&amp;gt; [
            // 省略
            'username' =&amp;gt; 'cakebox',
            'database' =&amp;gt; 'test_blog-tutorial_app',
            // 省略
        ],
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;ホストOSのhostsファイルの変更&lt;/h5&gt;

&lt;p&gt;ホストOSのhostsファイルに指示されたように &lt;code&gt;10.33.10.10 blog-tutorial.app&lt;/code&gt; の行を追加します。&lt;/p&gt;

&lt;h5&gt;Cakebox環境のチューニング&lt;/h5&gt;

&lt;p&gt;Cakeboxのデフォルト設定ではBehatを使ってアプリケーションをテストしようとすると、いくつか動かない箇所があったので、設定値をチューニングします。
まずボックスファイルのメモリを2048Mにアップします（デフォルトは1024M）。
次にxdebug.iniのxdebug.max&lt;em&gt;nesting&lt;/em&gt;levelの値を調整します。READMEでは&lt;code&gt;500&lt;/code&gt;を設定しています。もう少し値は小さくても大丈夫かもしれないですが、とりあえず500あれば大丈夫です。&lt;/p&gt;

&lt;p&gt;具体的な設定例は、githubのREADMEを参照してください。&lt;/p&gt;

&lt;h5&gt;Webサーバの設定&lt;/h5&gt;

&lt;p&gt;Behatからアプリケーションをテストするときは、ブラウザから通常操作するのと同じようにWebサーバを通過します。
そのため、アプリケーションが通常操作としてアクセスされたのか、Behatのテストでアクセスされたのかを識別して環境を切り替えてあげないと、データベースのデータがテストによって変更するので、通常操作のデータが失われてしまいます。&lt;/p&gt;

&lt;p&gt;このあたりの話（理由や手法）は、過去に何度か記事にしていたり、書籍&lt;a href="http://www.amazon.co.jp/CakePHP%E3%81%A7%E5%AD%A6%E3%81%B6%E7%B6%99%E7%B6%9A%E7%9A%84%E3%82%A4%E3%83%B3%E3%83%86%E3%82%B0%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-%E6%B8%A1%E8%BE%BA-%E4%B8%80%E5%AE%8F/dp/4844336789/ref=la_B004LVAF8Q_1_1?s=books&amp;amp;amp;ie=UTF8&amp;amp;amp;qid=1410066610&amp;amp;amp;sr=1-1"&gt;CakePHPで学ぶ継続的インテグレーション&lt;/a&gt;でも詳しく解説していますので、CakePHP2の内容ですが、一度手に取ってみてください。&lt;/p&gt;

&lt;p&gt;で、このサンプルはnginx用の設定ファイルを&lt;code&gt;blog-tutorial.app.test&lt;/code&gt;というファイルで用意しておいたので、これをCakeboxのnginxの設定ディレクトリにコピーして再起動するだけで大丈夫です。&lt;/p&gt;

&lt;p&gt;環境切り替え用に&lt;code&gt;blog-tutorial.app.test&lt;/code&gt;というホスト名でアクセスされたら、nginxで環境変数&lt;code&gt;CAKE_ENV&lt;/code&gt;に&lt;code&gt;test&lt;/code&gt;という文字列を設定するようにしています。
CakePHP3のアプリケーションでは&lt;code&gt;config/bootstrap.php&lt;/code&gt;で環境変数の設定値を見てDBの接続先が&lt;code&gt;test&lt;/code&gt;になるように設定します。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;if (getenv('CAKE_ENV') === 'test') {
    ConnectionManager::alias('test', 'default');
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CakePHP3ではConnectionManagerのaliasという機能でdefaultへ接続しようとしたときに、実際はtestの接続内容を参照するように設定することができるので、この機能を利用し、間違ってdefaultのテーブルが書き変わらないようにしています。&lt;/p&gt;

&lt;p&gt;より詳しい手順や、設定ファイルの内容はgithubのREADMEや設定ファイルを参照してください。&lt;/p&gt;

&lt;p&gt;Behatから参照可能なホスト名として&lt;code&gt;blog-tutorial.app.test&lt;/code&gt;をCakeboxのVM側の&lt;code&gt;/etc/hosts&lt;/code&gt;に追加します。&lt;/p&gt;

&lt;h4&gt;データベースのマイグレーション&lt;/h4&gt;

&lt;p&gt;データベースの生成はマイグレーションコマンドで一発です。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;bin/cake migrations migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Behatのテストを実行する&lt;/h4&gt;

&lt;p&gt;ここまで設定できれば、後はテストを実行するだけです。&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;vagrant@cakebox:~/Apps/blog-tutorial.app$ vendor/bin/behat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おそらくすべてグリーンで成功するはずです。
うまくいかなかったら、お気軽にgithubのissueに&lt;code&gt;日本語で&lt;/code&gt;書いてください。&lt;/p&gt;

&lt;h3&gt;どうやったのか？&lt;/h3&gt;

&lt;p&gt;まずCakePHP3で最初に注目したのは、単体テストがPHPUnitのコマンドから実行できるようになっていたことです。
これは過去に外部の様々なツールやアプリケーションとCakePHPを結合するときに一番悩んでいたところでした。&lt;/p&gt;

&lt;p&gt;PHPUnitからCakePHP3にどのように連動しているのか？を調べることから始めました。
PHPUnitは実行すると、カレントディレクトリのphpunit.xml（もしくはphpunit.xml.dist）を参照します。&lt;/p&gt;

&lt;h4&gt;PHPUnitがCakePHP3を呼び出す仕組みを知る&lt;/h4&gt;

&lt;p&gt;CakePHP3ではアプリケーションスケルトンを生成すると、ルートディレクトリに&lt;code&gt;phpunit.xml.dist&lt;/code&gt;が生成されます。&lt;/p&gt;
&lt;pre class="highlight xml"&gt;&lt;code&gt;&lt;span class="c"&gt;&amp;lt;!-- phpunit.xml.dist --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;phpunit&lt;/span&gt;
    &lt;span class="na"&gt;colors=&lt;/span&gt;&lt;span class="s"&gt;"true"&lt;/span&gt;
    &lt;span class="na"&gt;processIsolation=&lt;/span&gt;&lt;span class="s"&gt;"false"&lt;/span&gt;
    &lt;span class="na"&gt;stopOnFailure=&lt;/span&gt;&lt;span class="s"&gt;"false"&lt;/span&gt;
    &lt;span class="na"&gt;syntaxCheck=&lt;/span&gt;&lt;span class="s"&gt;"false"&lt;/span&gt;
    &lt;span class="na"&gt;bootstrap=&lt;/span&gt;&lt;span class="s"&gt;"./tests/bootstrap.php"&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;(1)&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;php&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;ini&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"memory_limit"&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;"-1"&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;ini&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"apc.enable_cli"&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/php&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- Add any additional test suites you want to run here --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;testsuites&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;testsuite&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"App Test Suite"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;./tests/TestCase&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/testsuite&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- Add plugin test suites here. --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/testsuites&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- Setup a listener for fixtures (2) --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;listeners&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;listener&lt;/span&gt;
        &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"\Cake\TestSuite\Fixture\FixtureInjector"&lt;/span&gt;
        &lt;span class="na"&gt;file=&lt;/span&gt;&lt;span class="s"&gt;"./vendor/cakephp/cakephp/src/TestSuite/Fixture/FixtureInjector.php"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arguments&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;object&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"\Cake\TestSuite\Fixture\FixtureManager"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/arguments&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/listener&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/listeners&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/phpunit&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このファイルを読むと、2つ重要な箇所があるのに気がつきます。&lt;/p&gt;

&lt;p&gt;まず(1)の &lt;code&gt;bootstrap=&amp;quot;./tests/bootstrap.php&amp;quot;&lt;/code&gt; という部分。
bootstrap属性にはPHPUnitが実行されるとき呼び出されるPHPコードを指定することができます。
ここからCakePHP3アプリケーションをテスト用にロードする場合、このファイルを呼び出せば外部ツールからCakePHP3が操作できるようになることがわかります。&lt;/p&gt;

&lt;p&gt;実はこのファイルを実際に見てみると、以下の1行しかありません。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;require dirname(__DIR__) . '/config/bootstrap.php';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストとは関係なく、アプリケーションの&lt;code&gt;config/bootstrap.php&lt;/code&gt;をロードしています。
おそらく将来テストに関する何か差分が必要になったときに、テスト側にだけ変更が発生すると思うので、テスト用にCakePHP3をロードする場合は&lt;code&gt;tests/bootstrap.php&lt;/code&gt;をロードしておいた方が良いでしょう。&lt;/p&gt;

&lt;p&gt;次に(2)のリスナー設定です。
PHPUnitのリスナーはPHPUnitのフックポイントでコールバックされる処理を記述できるクラスです。
CakePHP3ではフィクスチャ（DBのテストテーブルとデータを準備する仕組み）を投入するのに利用しています。
以下のように&lt;code&gt;FixtureInjector&lt;/code&gt;クラスのstartTestとendTestでテストケース開始／終了ごとにフィクスチャのロードとアンロードが対応するようになっています。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;class FixtureInjector implements PHPUnit_Framework_TestListener
{

    /**
     * Adds fixtures to a test case when it starts.
     *
     * @param \PHPUnit_Framework_Test $test The test case
     * @return void
     */
    public function startTest(PHPUnit_Framework_Test $test)
    {
        $test-&amp;gt;fixtureManager = $this-&amp;gt;_fixtureManager;
        if ($test instanceof TestCase) {
            $this-&amp;gt;_fixtureManager-&amp;gt;fixturize($test);
            $this-&amp;gt;_fixtureManager-&amp;gt;load($test);
        }
    }

    /**
     * Unloads fixtures from the test case.
     *
     * @param \PHPUnit_Framework_Test $test The test case
     * @param float $time current time
     * @return void
     */
    public function endTest(PHPUnit_Framework_Test $test, $time)
    {
        if ($test instanceof TestCase) {
            $this-&amp;gt;_fixtureManager-&amp;gt;unload($test);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;BehatからCakePHP3を呼び出す仕組みに流用する&lt;/h4&gt;

&lt;p&gt;ここまでの内容が外部ツールからCakePHP3のアプリケーションをテストするのに重要な部分です。
PHPUnitがCakePHP3を呼び出すのと同じようにする仕組みをBehatのFeatureContextクラスに用意します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;features/bootstrap/FeatureContext.php&lt;/code&gt;というBehatが読み込むファイルに記述します。
CakePHP2とBDDプラグインによるインテグレーションではBehatのバージョンが2系でしたが、CakePHP3との連携では最新の3系を利用しています。
Behat3からはBehat1系、2系で利用していたファイル構成と異なっています。従来、&lt;code&gt;support/bootstrap.php&lt;/code&gt;や&lt;code&gt;support/hooks.php&lt;/code&gt;あたりに書いていたコードはすべてContextクラス内に記述することになります。&lt;/p&gt;

&lt;p&gt;Behat3からはFeatureContextにブートストラップ記述を、それ以外のコンテキストは用途に応じて別のコンテキストクラスに分割する方がスマートに記述できそうです。
Behat2では複数のコンテキストクラスを使う場合、FeatureContextでインクルードしないといけなかったのですが、Behat3では&lt;code&gt;behat.yml&lt;/code&gt;上で記述できるのでより簡単になっています。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;class FeatureContext implements Context, SnippetAcceptingContext
{
    public function __construct()
    {
        require_once dirname(dirname(__DIR__)) . '/tests/bootstrap.php'; // (1)

        // Always connect test database
        ConnectionManager::alias('test', 'default'); // (2)

        Fabricate::config(function($config) { // (3)
            $config-&amp;gt;adaptor = new CakeFabricateAdaptor([
                CakeFabricateAdaptor::OPTION_FILTER_KEY =&amp;gt; true,
                CakeFabricateAdaptor::OPTION_VALIDATE   =&amp;gt; false
            ]);
        });

        $this-&amp;gt;fixtureInjector = new FixtureInjector(new FixtureManager()); //(4)
        $this-&amp;gt;fixture = new BddAllFixture();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;(1)は、phpunit.xmlのbootstrapと同様にCakePHP3の&lt;code&gt;tests/bootstrap.php&lt;/code&gt;を呼び出します。&lt;/li&gt;
&lt;li&gt;(2)は、Behatのステップ定義からテストデータを投入するときに、testの接続設定を参照するようにエイリアスを設定します。&lt;/li&gt;
&lt;li&gt;(3)は、テストデータジェネレータ&lt;a href="https://github.com/sizuhiko/cakephp-fabricate-adaptor"&gt;Fabricate&lt;/a&gt;の初期設定です。FabricateもCakePHP3対応されています。&lt;/li&gt;
&lt;li&gt;(4)は、phpunit.xmlのリスナー部分を模して、Behatのシナリオ毎にフィクスチャが動くようにFixtureInjectorのインスタンスを生成しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;BehatからCakePHP3のフィクスチャを利用する&lt;/h4&gt;

&lt;p&gt;(4)で書いたとおり、FixtureInjectorのインスタンスを生成したので、Behatのフックポイントを使ってシナリオ開始時にフィクスチャをロードし、シナリオ終了時にフィクスチャをアンロードするようにします。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;    /** @BeforeScenario */
     public function beforeScenario(BeforeScenarioScope $scope)
     {
        $this-&amp;gt;fixtureInjector-&amp;gt;startTest($this-&amp;gt;fixture);
     }

     /** @AfterScenario */
     public function afterScenario(AfterScenarioScope $scope)
     {
        $this-&amp;gt;fixtureInjector-&amp;gt;endTest($this-&amp;gt;fixture, time());
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にフィクスチャを利用するためには、&lt;code&gt;$this-&amp;gt;fixture&lt;/code&gt;のクラスがCakePHP3のTestCaseでなければならないので、&lt;code&gt;$fixtures&lt;/code&gt;という利用するフィクスチャファイルの配列を定義しただけのクラスを用意してFixtureInjectorに渡すようにします。&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;class BddAllFixture extends TestCase {
    public $fixtures = [
        'Categories' =&amp;gt; 'app.categories',
        'Articles'   =&amp;gt; 'app.articles',
        'Users'      =&amp;gt; 'app.users',
        'Categories' =&amp;gt; 'app.categories'
    ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このあたりの話も、書籍&lt;a href="http://www.amazon.co.jp/CakePHP%E3%81%A7%E5%AD%A6%E3%81%B6%E7%B6%99%E7%B6%9A%E7%9A%84%E3%82%A4%E3%83%B3%E3%83%86%E3%82%B0%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-%E6%B8%A1%E8%BE%BA-%E4%B8%80%E5%AE%8F/dp/4844336789/ref=la_B004LVAF8Q_1_1?s=books&amp;amp;amp;ie=UTF8&amp;amp;amp;qid=1410066610&amp;amp;amp;sr=1-1"&gt;CakePHPで学ぶ継続的インテグレーション&lt;/a&gt;でも詳しく解説していますので、CakePHP2の内容ですが、一度手に取ってみてください。
CakePHP3になって、メソッドやクラスが一部変わりましたが、BehatとCakePHPをインテグレーションするためにおさえておかないといけないポイントはほとんど変わっていません。&lt;/p&gt;

&lt;p&gt;後はBehat3のドキュメント、CakePHP3のドキュメントを見ながら進めていくと、エンド to エンドのテストが容易に記述できるようになります。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;GithubのREADMEに書いた内容をすべて日本語にした訳ではないのですが、要所をかいつまんで重要な部分を解説しました。
より詳しい内容などはREADMEを見ていただければと思います。&lt;/p&gt;

&lt;p&gt;また、BDDプラグインのサンプルアプリにはあった、日本語のシナリオや、JavaScriptを使ったテストなど、Behat3になって大きく変わってはいませんが、サンプルアプリケーションに少しずつ載せられたらなぁと思っています。
何かうまく動かないなどあれば、気軽にGithubのissueに投稿お願いします（日本語でOKです）。&lt;/p&gt;
</content>
  </entry>
</feed>
