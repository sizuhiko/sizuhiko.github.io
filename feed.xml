<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2023-09-27T17:25:00+09:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>マルチプルレポをモノレポへコミットログを残しながら移行する</title>
    <link rel="alternate" href="http://blog.url.com/2023/09/27/converting-multiple-repos-into-a-monorepo.html"/>
    <id>http://blog.url.com/2023/09/27/converting-multiple-repos-into-a-monorepo.html</id>
    <published>2023-09-27T17:25:00+09:00</published>
    <updated>2023-09-28T16:16:47+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h3&gt;背景&lt;/h3&gt;

&lt;p&gt;プロジェクトで複数のAPIサーバーや、マイクロサービスなどを展開するのに、OpenAPI の定義を置くリポジトリを個々に作っていたのですが、メンテナンス性を考えてマルチプルレポからモノレポへ移行することにしました。&lt;/p&gt;

&lt;p&gt;基本的に OpenAPI の定義（yamlファイル）の内容と、デプロイ先（AWS S3のWebホスティング先バケット）が違うぐらいで、それ以外の内容はまったく一緒であるリポジトリが複数ある感じです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app-a-apidoc&lt;/li&gt;
&lt;li&gt;app-b-apidoc&lt;/li&gt;
&lt;li&gt;service-account-apidoc&lt;/li&gt;
&lt;li&gt;service-payment-apidoc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;みたいなマルチプルレポを &lt;code&gt;apidoc&lt;/code&gt; モノレポへまとめていきます。&lt;/p&gt;

&lt;p&gt;各 apidoc は &lt;a href="https://www.npmjs.com/package/swagger-ui-dist"&gt;swagger-ui-dist&lt;/a&gt; に yaml ファイルを入れて、Webホスティングしている S3 バケットにデプロイしています。
ビルドスクリプトは gulp で、デプロイは serverless framework に serverless-s3-sync プラグインを入れて実行しています。&lt;/p&gt;

&lt;h3&gt;リポジトリの移行の準備&lt;/h3&gt;

&lt;p&gt;リポジトリを移行するにあたり &lt;a href="https://medium.com/@chris_72272/keeping-git-history-when-converting-multiple-repos-into-a-monorepo-97641744d928"&gt;Keeping git history when converting multiple repos into a monorepo&lt;/a&gt; という記事がとても役にたったので、こちらの手順を参考にして紹介していきます。&lt;/p&gt;

&lt;h4&gt;ディレクトリ構造決定&lt;/h4&gt;

&lt;p&gt;まず最初にモノレポ移行後のディレクトリ構造を検討します。
よくある npm のパッケージをモノレポにしている場合だと&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;packages
  +-- package-a
  +-- package-b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;みたいな階層にすることが多いんじゃないかな？と思います。
参考記事だと &lt;code&gt;projects/*&lt;/code&gt; のような感じですね。
aws-sdk v3 だと clients や lib, packages など目的別にいろいろ分けているようです。&lt;/p&gt;

&lt;p&gt;そこで今回私たちは&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;apps
  +-- a
  +-- b
services
  +-- account
  +-- payment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;みたいなディレクトリ構造にしました。これはそれぞれのプロジェクトや、まとめたいリポジトリにもよるので、個別に検討しましょう。&lt;/p&gt;

&lt;h4&gt;既存リポジトリのディレクトリ変更&lt;/h4&gt;

&lt;p&gt;ディレクトリ構造が決まったら、既存リポジトリをそのディレクトリに合わせて階層を変更します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;cd app-a-apidoc
mkdir -p apps/a
git mv -k * apps/a
git mv -k .* apps/a
git commit -m "chore: move all files into apps/a"
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;既存リポジトリをチェックアウトしたディレクトリに移動&lt;/li&gt;
&lt;li&gt;モノレポにしたときのディレクトリツリーを作成&lt;/li&gt;
&lt;li&gt;2のディレクトリ下にすべてのファイルを移動。移動には &lt;code&gt;git mv&lt;/code&gt; コマンドを使う&lt;/li&gt;
&lt;li&gt;コミット&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;この作業を移行対象のすべての既存リポジトリで実施していきます。&lt;/p&gt;

&lt;h4&gt;モノレポの作成&lt;/h4&gt;

&lt;p&gt;GitHub上でリポジトリを作ってチェックアウトするか、 &lt;code&gt;git init&lt;/code&gt; コマンドでローカルにモノレポのフォルダを準備します。
続いて、モノレポリポジトリにワークスペースのルートディレクトリを作っておきます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;mkdir apps
mkdir services
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;git remote add&lt;/code&gt; を使ってローカルディレクトリのリポジトリ（既存リポジトリのディレクトリ変更でディレクトリ変更してコミットしたもの）を追加します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;git remote add -f app-a-apidoc ../app-a-apidoc
git remote add -f app-b-apidoc ../app-b-apidoc
git remote add -f service-account-apidoc ../service-account-apidoc
git remote add -f service-payment-apidoc ../service-payment-apidoc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;で、それらをモノレポの中にマージしていきます。マージするブランチが &lt;code&gt;main&lt;/code&gt; であると仮定します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;git merge app-a-apidoc/main --allow-unrelated-histories
git merge app-b-apidoc/main --allow-unrelated-histories
git merge service-account-apidoc/main --allow-unrelated-histories
git merge service-payment-apidoc/main --allow-unrelated-histories
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最後にリモートを削除しましょう。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;git remote remove app-a-apidoc
git remote remove app-b-apidoc
git remote remove service-account-apidoc
git remote remove service-payment-apidoc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;モノレポの設定&lt;/h3&gt;

&lt;p&gt;ここまでで既存のリポジトリを1つのモノレポにコミットログ付きで合体できました。
続いて、モノレポで開発作業ができるように環境整備をしましょう。&lt;/p&gt;

&lt;h4&gt;ワークスペースを設定する&lt;/h4&gt;

&lt;p&gt;モノレポのルートディレクトリで &lt;code&gt;npm init&lt;/code&gt; コマンドを実行して &lt;code&gt;package.json&lt;/code&gt; を作ります。
作成した &lt;code&gt;package.json&lt;/code&gt; にワークスペースに関する設定を追加します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;  &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;private&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;workspaces&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;apps/*&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;services/*&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;
  &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;依存関係の設定&lt;/h4&gt;

&lt;p&gt;続いて、各リポジトリで使っていた &lt;code&gt;devDependencies&lt;/code&gt; や &lt;code&gt;dependencies&lt;/code&gt; の依存関係をモノレポのルートディレクトリにある &lt;code&gt;package.json&lt;/code&gt; に移動します。
通常は各リポジトリ共通のものだけですが、今回の apidoc ではすべて共通だったので、そのままコピペしました。&lt;/p&gt;

&lt;p&gt;ワークスペース（apps や services）にある &lt;code&gt;package.json&lt;/code&gt; の &lt;code&gt;devDependencies&lt;/code&gt; や &lt;code&gt;dependencies&lt;/code&gt; を削除し、 &lt;code&gt;package-lock.json&lt;/code&gt; も削除します。&lt;/p&gt;

&lt;p&gt;最後にルートディレクトリで &lt;code&gt;npm i&lt;/code&gt; を実行して依存関係をインストールします。&lt;/p&gt;

&lt;h4&gt;各 apidoc の整理&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.npmrc&lt;/code&gt; や &lt;code&gt;.gitignore&lt;/code&gt; , &lt;code&gt;.editorconfig&lt;/code&gt; など必要な設定ファイルをワークスペースからルートディレクトリに移動しておきます。&lt;/p&gt;

&lt;p&gt;その他共通になったものはルートディレクトリ下に移動しておくと良いでしょう。&lt;/p&gt;

&lt;h4&gt;GitHub Actions の統合&lt;/h4&gt;

&lt;p&gt;ワークスペース（apps や services）にある &lt;code&gt;.github&lt;/code&gt; をどれかルートディレクトリに移動して、ワークスペース側からは削除します。
単に全部のワークスペースをビルドしたりデプロイするだけなら &lt;code&gt;-ws&lt;/code&gt; オプションを追加するとすべてのワークスペースに対してコマンドを実行するようになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;    &lt;span class="na"&gt;steps&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;uses&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;actions/checkout@v3&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm ci&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm run -ws build&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm run -ws deploy&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まぁでも通常はそんなことなく、以下のパターンを考慮する必要があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートディレクトリの package.json で定義している依存関係にアップデートがあった（dependabotなど）&lt;/li&gt;
&lt;li&gt;ワークスペースのファイルが修正された&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者はすべてのワークスペースに対して Action を実行したほうが良いのですが、後者は変更があったワークスペースだけの実行に絞り込みたいところです。&lt;/p&gt;

&lt;p&gt;そこで利用できるのが &lt;a href="https://github.com/AlexShukel/get-changed-workspaces-action"&gt;Get changed workspaces action&lt;/a&gt; です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;&lt;span class="na"&gt;jobs&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="na"&gt;get-changed-workspaces&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="na"&gt;outputs&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;packages&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;${{ steps.changed-packages.outputs.packages }}&lt;/span&gt;
      &lt;span class="na"&gt;empty&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;${{ steps.changed-packages.outputs.empty }}&lt;/span&gt;
    &lt;span class="na"&gt;steps&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;Check out repository code&lt;/span&gt;
        &lt;span class="na"&gt;uses&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;actions/checkout@v3&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;Find changed workspaces&lt;/span&gt;
        &lt;span class="na"&gt;uses&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;AlexShukel/get-changed-workspaces-action@v2.0.0&lt;/span&gt;
        &lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;changed-packages&lt;/span&gt;
  &lt;span class="na"&gt;deploy&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="na"&gt;needs&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="pi"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;get-changed-workspaces&lt;/span&gt;&lt;span class="pi"&gt;]&lt;/span&gt;
    &lt;span class="na"&gt;if&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;${{ !fromJson(needs.get-changed-workspaces.outputs.empty) }}&lt;/span&gt;
    &lt;span class="na"&gt;strategy&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;matrix&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
        &lt;span class="na"&gt;package&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;${{ fromJson(needs.get-changed-workspaces.outputs.packages) }}&lt;/span&gt;  
    &lt;span class="na"&gt;steps&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;uses&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;actions/checkout@v3&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm ci&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm run -w ${{ matrix.package.name }} build&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm run -w ${{ matrix.package.name }} deploy&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この Action を使うと変更があったワークスペースの名前を配列型式で取得できます。
ワークスペースに変更がないときは &lt;code&gt;empty&lt;/code&gt; でわかるので、 &lt;code&gt;if&lt;/code&gt; 文で制御して何もしないように設定も可能です。&lt;/p&gt;

&lt;p&gt;で、特定のワークスペースに対して npm コマンドを実行したい場合は &lt;code&gt;-w ワークスペース名&lt;/code&gt; オプションを指定します。&lt;/p&gt;

&lt;p&gt;そこで、 &lt;code&gt;.github/workflows&lt;/code&gt; には以下のファイルを設置することにしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;build-all.yml&lt;/li&gt;
&lt;li&gt;build.yml&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者は &lt;code&gt;ルートディレクトリの package.json で定義している依存関係にアップデートがあった（dependabotなど）&lt;/code&gt; を想定していて、以下のような条件で起動したら、 &lt;code&gt;-ws&lt;/code&gt; オプションですべてのワークスペースで実行されるようにしています。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;&lt;span class="na"&gt;on&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="na"&gt;workflow_dispatch&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="na"&gt;push&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="na"&gt;paths&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;package.json&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;package-lock.json&lt;/span&gt;
    &lt;span class="na"&gt;branches&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;master&lt;/span&gt;
&lt;span class="na"&gt;jobs&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="na"&gt;deploy&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="na"&gt;steps&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;uses&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;actions/checkout@v3&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm ci&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm run -ws build&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm run -ws deploy&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;後者は &lt;code&gt;Get changed workspaces action&lt;/code&gt; を使って個別のワークスペースビルドされるように設定しました。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;マルチプルレポ、モノレポ、それぞれに良いところはあると思います。
必ずモノレポが良いというものでもないでしょう。
それぞれのプロジェクトやリポジトリの運用を見極めて選択していきたいですね。&lt;/p&gt;

&lt;p&gt;マルチプルレポからモノレポへ移行するときに、本記事が参考になれば幸いです。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>tsyringe を TypeScript 5 で使う方法</title>
    <link rel="alternate" href="http://blog.url.com/2023/05/02/tsyringe-with-typescript-5.html"/>
    <id>http://blog.url.com/2023/05/02/tsyringe-with-typescript-5.html</id>
    <published>2023-05-02T15:00:00+09:00</published>
    <updated>2023-05-02T15:17:42+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="https://github.com/microsoft/tsyringe"&gt;tsyringe&lt;/a&gt; は、Microsoft のオーガナイゼーションにある、JavaScript/TypeScript用のDIコンテナです。&lt;/p&gt;

&lt;p&gt;Microsoft は TypeScript の親だし、DIコンテナあるんだったら使うよなーというぐらいの理由で使っていましたが、ここ数年はアップデートのリリースがありません。
この記事を書いている時点での最新版は、2020/11/9 に出た &lt;a href="https://github.com/microsoft/tsyringe/releases/tag/v4.4.0"&gt;v4.4.0&lt;/a&gt; です。&lt;/p&gt;

&lt;h3&gt;TypeScript 5 でコンパイルエラーになる&lt;/h3&gt;

&lt;p&gt;tsyringe を TypeScript 5 で利用しようとすると、コンパイルエラーになります。
で、さすがに利用者が多いライブラリだけあって、すぐ issue &lt;a href="https://github.com/microsoft/tsyringe/issues/221"&gt;TypeScript 5.0 Support of tighter parameter decorator checking&lt;/a&gt; が出ました。
しばらくしたら PR &lt;a href="https://github.com/microsoft/tsyringe/pull/226"&gt;fix: allow propertyKey to be undefined&lt;/a&gt; も出ました。PRが 2023/3/26 に出て、マージされたのは 2023/4/17 です。&lt;/p&gt;

&lt;p&gt;それから2週間ぐらい経過しましたが、リリースされる気配はありません&amp;hellip;.&lt;/p&gt;

&lt;h3&gt;でも TypeScript 5 を使いたいんや&lt;/h3&gt;

&lt;p&gt;まぁそう思いますよね。
僕らのプロジェクトでもそう思ったんで、パッチを作りました。&lt;/p&gt;

&lt;p&gt;プロジェクトルート(package.json とか置いているディレクトリ)に &lt;code&gt;tsyringe.d.ts&lt;/code&gt; を置いて、型定義をオーバーライドする感じです。
例えば以下のような感じです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;require&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;tsyringe/dist/typings/index&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;declare&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;inject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;token&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;InjectionToken&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;any&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;target&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;any&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;propertyKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;symbol&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;undefined&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parameterIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;any&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;injectable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;injectable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;DependencyContainer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;tsyringe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まずコンパイルエラーになるのは &lt;code&gt;inject&lt;/code&gt; 関数なので、それをオーバーライドします。
次に、プロジェクトで import している関数や型があれば、それぞれ &lt;code&gt;const&lt;/code&gt; や &lt;code&gt;type&lt;/code&gt; で宣言して require した内容からそのまま export するようにしました。&lt;/p&gt;

&lt;p&gt;これはマージされている PR が型定義ぐらいしか修正しておらず、実装に関しては何も修正されていなかったので、問題なしと判断して型定義だけをオーバーライドしたパッチを作ることにしました。&lt;/p&gt;

&lt;h3&gt;で、どうなの？&lt;/h3&gt;

&lt;p&gt;現時点動作に問題はなく、普通に TypeScript 5 で tsyringe が使えています。
PRがマージされて、すぐリリースされるんじゃないか？と思ったので、この内容を記事にする必要もないかな？と思っていたのですが、
リリースされる気配を感じないので、僕らのやっている方法が少しでも役に立てばと思い、記事にしました。
はやく TypeScript 5 対応が正式リリースされて欲しいですね。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>LocalStack を使って aws-sdk の Integration Test を実行する</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/19/integration-test-using-localstack.html"/>
    <id>http://blog.url.com/2023/04/19/integration-test-using-localstack.html</id>
    <published>2023-04-19T16:12:00+09:00</published>
    <updated>2023-04-19T16:38:55+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="/2023/01/04/migrate-aws-sdk-node-js-v2-to-v3.html"&gt;AWS Lambda の Node.js 14 を 18 に移行する（aws-sdk v3 移行編）&lt;/a&gt; の中でも書いたように、aws-sdk v3 を使ったコードを UnitTest するには &lt;a href="https://github.com/m-radzikowski/aws-sdk-client-mock"&gt;AWS SDK v3 Client mock&lt;/a&gt; を利用してモックした方が簡単です。&lt;/p&gt;

&lt;p&gt;一方で少し IntegrationTest をしたいと思うこともあるでしょう。そうしたときは LocalStack の利用が便利です。
手元も環境なら Docker の Extension で動きます。
CI 環境、たとえば GitHub Actions ならサービスでコンテナ起動すれば大丈夫です。&lt;/p&gt;

&lt;h3&gt;インテグレーションテストでのエンドポイント&lt;/h3&gt;

&lt;p&gt;こんな感じでテストコードで endpoint を切り替えられるようにしておくとローカルとCI環境のどちらでもテストを実行しやすくなります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="na"&gt;credentials&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="na"&gt;accessKeyId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;dummy&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="na"&gt;secretAccessKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;summy&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="na"&gt;endpoint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;`http://&lt;/span&gt;&lt;span class="p"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;env&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TEST_AWS_HOSTNAME&lt;/span&gt; &lt;span class="o"&gt;??&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;localhost&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;:4566`&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="na"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="s1"&gt;ap-northeast-1&lt;/span&gt;&lt;span class="dl"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;stepFunctions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;SFNClient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;options&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;手元では localhost で良いし、CI環境（たとえば GitHub Actions ） なら、以下のようにしておくと良いです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;    &lt;span class="na"&gt;container&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;node:18&lt;/span&gt;
    &lt;span class="na"&gt;services&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;localstack&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
        &lt;span class="na"&gt;image&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;localstack/localstack&lt;/span&gt;
    &lt;span class="na"&gt;env&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;TEST_AWS_HOSTNAME&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;localstack&lt;/span&gt;
    &lt;span class="na"&gt;steps&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;npm t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;LocalStack v2.0 以降での変更点&lt;/h3&gt;

&lt;p&gt;最近バージョンが 2.0 になった LocalStack ですが Lambda 関連で大きな変更がありました。
基本的に Lambda を利用しなければ問題はありませんが、特に問題なければ localstack サービスを以下のように設定しておくと安心です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight yaml"&gt;&lt;code&gt;    &lt;span class="na"&gt;container&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;node:18&lt;/span&gt;
    &lt;span class="na"&gt;services&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
      &lt;span class="na"&gt;localstack&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
        &lt;span class="na"&gt;image&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;localstack/localstack&lt;/span&gt;
        &lt;span class="na"&gt;env&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
          &lt;span class="na"&gt;LAMBDA_SYNCHRONOUS_CREATE&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
        &lt;span class="na"&gt;volumes&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
          &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;/var/run/docker.sock:/var/run/docker.sock&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Actions のホストコントローラの docker.sock をマウントすることで LocalStack の中で Lambda が起動できるようになります。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href="https://github.com/localstack/localstack/releases/tag/v2.0.0"&gt;公式の v2.0.0 リリースノート&lt;/a&gt; の &lt;code&gt;Lambda&lt;/code&gt; 部分に書いてありますので、読んでみてください。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;単体テストで LocalStack 使うのはやりすぎだと思いますが、部分的にインテグレーションテストしたい、といった場合には有用な方法かな、と思いますので、用途に応じて使い分けられると良いですね。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>AWS SDK v3 のモジュールと利用方法</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/18/generation-code-aws-sdk-v3.html"/>
    <id>http://blog.url.com/2023/04/18/generation-code-aws-sdk-v3.html</id>
    <published>2023-04-18T12:21:00+09:00</published>
    <updated>2023-04-18T15:01:28+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;このところ何度か aws-sdk v3 について記事を書いてきましたが、こちらは現時点でのベストプラクティスというか、追記を含むまとめ記事になります。&lt;/p&gt;

&lt;h3&gt;ランタイムに含まれないモジュールがある？&lt;/h3&gt;

&lt;p&gt;aws-sdk を使って Lambda から Lambda を実行するときのコードは、公式のExampleコードを見ると以下のようになっています。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/awsdocs/aws-doc-sdk-examples/blob/main/javascriptv3/example_code/lambda/actions/invoke.js"&gt;https://github.com/awsdocs/aws-doc-sdk-examples/blob/main/javascriptv3/example_code/lambda/actions/invoke.js&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="cm"&gt;/**
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LambdaClient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LogType&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/client-lambda&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;createClientForDefaultRegion&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;../../libs/utils/util-aws-sdk.js&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/** snippet-start:[javascript.v3.lambda.actions.Invoke] */&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;invoke&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;funcName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;createClientForDefaultRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;LambdaClient&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="na"&gt;FunctionName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;funcName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="na"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;stringify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="na"&gt;LogType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;LogType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;});&lt;/span&gt;

  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LogResult&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;command&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;logs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;LogResult&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;base64&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;logs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="cm"&gt;/** snippet-end:[javascript.v3.lambda.actions.Invoke] */&lt;/span&gt;

&lt;span class="k"&gt;export&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;invoke&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで注目して欲しいのは&lt;/p&gt;

&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Payload: JSON.stringify(payload),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;の部分なのですが、これは TypeScript で記述すると型違反でエラーになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;    &lt;span class="cm"&gt;/**
     * &amp;lt;p&amp;gt;The JSON that you want to provide to your Lambda function as input.&amp;lt;/p&amp;gt;
     *          &amp;lt;p&amp;gt;You can enter the JSON directly. For example, &amp;lt;code&amp;gt;--payload '\{ "key": "value" \}'&amp;lt;/code&amp;gt;. You can also
     *       specify a file path. For example, &amp;lt;code&amp;gt;--payload file://payload.json&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
     */&lt;/span&gt;
    &lt;span class="nx"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;?:&lt;/span&gt; &lt;span class="nb"&gt;Uint8Array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;公式 Example のコードの意味とは&amp;hellip; というところですが、&lt;/p&gt;

&lt;p&gt;で、そういう issue やら SlackOverflow があって&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/aws/aws-sdk-js-v3/issues/4623"&gt;https://github.com/aws/aws-sdk-js-v3/issues/4623&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;InvocationType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;LambdaClient&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/client-lambda&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;toUint8Array&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/util-utf8&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;lambda&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;LambdaClient&lt;/span&gt;&lt;span class="p"&gt;({});&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;InvokeCommand&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
      &lt;span class="na"&gt;FunctionName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;env&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LAMBDA_ARN&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="na"&gt;InvocationType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;InvocationType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RequestResponse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="na"&gt;Payload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;toUint8Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}),&lt;/span&gt;
  &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こんな感じで &lt;code&gt;Uint8Array&lt;/code&gt; に変換する必要があります。
そこで &lt;code&gt;@aws-sdk/util-utf8&lt;/code&gt; を使ったのですが、これが Node.js v18 の Lambda インスタンスだと見つからないとエラーになります。&lt;/p&gt;

&lt;h3&gt;執筆時点での Lambda インスタンスの sdk バージョンは 3.188.0&lt;/h3&gt;

&lt;p&gt;以下のページから現在のランタイムに入っている sdk バージョンがわかります。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtimes.html"&gt;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtimes.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;執筆時点では 3.188.0 なので、 GitHub リポジトリでそのタグのコードを見てみると、確かにそんなパッケージはありません。
それどころか、 &lt;code&gt;@aws-sdk/util-utf8-node&lt;/code&gt; と &lt;code&gt;@aws-sdk/util-utf8-browser&lt;/code&gt; という2つのパッケージに分かれていました。
どうも、3.300.0 あたりでパッケージを統合したようです。&lt;/p&gt;

&lt;p&gt;NPMのレジストリをみると、&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.npmjs.com/package/@aws-sdk/util-utf8-node"&gt;https://www.npmjs.com/package/@aws-sdk/util-utf8-node&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Deprecated package&lt;/p&gt;

&lt;p&gt;This internal package is deprecated in favor of @aws-sdk/util-utf8.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;のように書いてあります。&lt;/p&gt;

&lt;p&gt;ちなみに、最新の GitHub リポジトリからは、 &lt;code&gt;util-utf8-node&lt;/code&gt; が完全に削除されています。&lt;/p&gt;

&lt;h3&gt;状況を整理し、これから発生することを整理&lt;/h3&gt;

&lt;p&gt;つまり、 3.188.0 で &lt;code&gt;@aws-sdk/util-utf8-node&lt;/code&gt; を使っていて、Lambda の zip に sdk を含めていない人は、ランタイムのアップデートで突然 Lambda が動かなくなる可能性があるということです。&lt;/p&gt;

&lt;p&gt;これはセマンティックバージョニングとしては破壊的変更なのでメジャーバージョンアップ相当ですが、そもそも aws-sdk がセマンティックバージョニングされているかどうかはわかりません（たぶんされていない）。&lt;/p&gt;

&lt;p&gt;僕は長い間、公式ドキュメント「.zip ファイルアーカイブで Node.js Lambda 関数をデプロイする」に書いてある&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;関数が標準ライブラリまたは AWS SDK ライブラリにのみ依存する場合は、これらのライブラリを .zip ファイルに含める必要はありません&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/nodejs-package.html"&gt;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/nodejs-package.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;というポリシーを信じていました。
著名な Serverless Framework でもデフォルトの挙動では zip ファイルを作成するときに aws-sdk を除外するようになってます。&lt;/p&gt;

&lt;h3&gt;道を間違える前に AWS さんに確認してみた&lt;/h3&gt;

&lt;p&gt;僕の懸念は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aws-sdk は zip に含めるべきか？&lt;/li&gt;
&lt;li&gt;後方互換性がなくなる変更があるけど、アップデートの方針はどうなっているか？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というあたりです。&lt;/p&gt;

&lt;h4&gt;aws-sdk は zip に含めるべきか？&lt;/h4&gt;

&lt;p&gt;こちらは「はい」が正解ということです。
&lt;a href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/best-practices.html"&gt;AWS Lambda 関数を使用するためのベストプラクティス&lt;/a&gt; に &lt;code&gt;関数のデプロイパッケージ内で依存関係を制御します&lt;/code&gt; という部分があり、zip に含めた方が良いとなっています。&lt;/p&gt;

&lt;p&gt;しかし aws-sdk のサイズはモジュール化されているとはいえ、Lambdaの上限サイズを考えるとかなりの割合を占めてしまうので、できればランタイムを使いたいとことです。&lt;/p&gt;

&lt;h4&gt;後方互換性がなくなる変更があるけど、アップデートの方針はどうなっているか？&lt;/h4&gt;

&lt;p&gt;こちらの回答をふりかえる前に、aws-sdk v3 のモジュール構造について補足しておきます。
GitHub のリポジトリにある README &lt;a href="https://github.com/aws/aws-sdk-js-v3#generated-code"&gt;Generated Code&lt;/a&gt;] によると以下のとおりです。ざっくり要約しました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;v3 コードベースは、AWSサービスが公開しているモデルから生成されています。
smithy-typescript で &lt;code&gt;/clients&lt;/code&gt; サブディレクトリ内のコードを生成し、これらのパッケージは @aws-sdk/client-XXXX のような名前になります。&lt;/p&gt;

&lt;p&gt;クライアントは、 &lt;code&gt;/packages&lt;/code&gt; にあるユーティリティコードに依存します。これらのコードは手動で記述されていて、通常あまり役に立ちません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/lib&lt;/code&gt; には高レベルのライブラリがあります。 client をラップして操作しやすくするライブラリです。よくある例は &lt;code&gt;@aws-sdk/lib-dynamodb&lt;/code&gt; で Amazon DynamoDB のアイテムの操作を簡素化するものや、 &lt;code&gt;@aws-sdk/lib-storage&lt;/code&gt; で S3 の multipartUpload での並列アップロードを簡素化するものです。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;続けて、以下のようにも書いてあります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;/packages 手動でコード更新が行われる場所で、 NPM に @aws-sdk/XXXX で公開されています。特別なプレフィックスはありません。&lt;/li&gt;
&lt;li&gt;/clients  このディレクトリのコードは自動生成され、 /packages に依存します。AWS のサービスと 1 対 1 です。通常、手動編集はここでは行わないでください。@aws-sdk/client-XXXX で NPM に公開されます。&lt;/li&gt;
&lt;li&gt;/lib このディレクトリは、 /clients に依存します。既存の AWS サービスと操作をラップして、Javascript での作業を容易にします。@aws-sdk/lib-XXXX で NPM に公開されています。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上記以外にも private というのもあったりしますが、これは名前からも明らかに非公開のモジュールだとわかります。
NPM 公開されていて、僕らが利用することができるものが client / packages / lib にあるといった感じでしょうか。&lt;/p&gt;

&lt;p&gt;上記3つのディレクトリについての AWS アップデートポリシーは以下のようなものになるそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;client ユーザーが利用する想定のモジュールであり、破壊的変更は行われない&lt;/li&gt;
&lt;li&gt;lib ユーザーが利用する想定のモジュールであり、破壊的変更は行われない&lt;/li&gt;
&lt;li&gt;package client からの利用を想定している内部モジュールなので破壊的変更の可能性がある（ただしドキュメントに明示されていない）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;package に入っているもので、README に利用方法が解説されているもの、たとえば S3 の署名付きURLを発行するためのライブラリ &lt;a href="https://github.com/aws/aws-sdk-js-v3/tree/main/packages/s3-request-presigner"&gt;@aws-sdk/s3-request-presigner&lt;/a&gt; はユーザーからの利用が想定されていて、破壊的変更は行われないようです。
しかし、README にAPIの解説がないものについては内部利用を想定しているため、破壊的変更もありえると。&lt;/p&gt;

&lt;p&gt;後者は private ディレクトリに入れた方が良いのでは？と思わなくはないですが、何か理由があるんでしょうかね。&lt;/p&gt;

&lt;p&gt;今回のようにドキュメントに記述がない &lt;code&gt;@aws-sdk/util-utf8-node&lt;/code&gt; を使いたい場合は zip に必ず含むようにしましょう。
それ以外は zip の容量が厳しければ v2 のときと同じようにランタイムに依存する方が良いと思います。aws-sdk の更新頻度がかなり多いので、どれがセキュリティパッチかわからないし、できればランタイムでの更新に期待したいという思いもあります。&lt;/p&gt;

&lt;h3&gt;さいごに&lt;/h3&gt;

&lt;p&gt;これまでの aws-sdk v3 / Node.js v18 への移行記事を一覧にしてみます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="/2022/12/30/migrate-aws-lambda-node-js-14-to-18.html"&gt;AWS Lambda の Node.js 14 を 18 に移行する（CI/CD環境移行編）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/01/04/migrate-aws-sdk-node-js-v2-to-v3.html"&gt;AWS Lambda の Node.js 14 を 18 に移行する（aws-sdk v3 移行編）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/03/aws-sdk-v3-ts2345.html"&gt;aws-sdk v3 で TS2345 が出てコンパイルエラーになる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/04/aws-sdk-v3-compile-error-2.html"&gt;aws-sdk v3 でコンパイルエラーになる - その２&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/05/aws-sdk-v3-changed-enum-to-const.html"&gt;Node.js v18 / aws-sdk v3 の Lambda アプリが突然動かなくなる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2023/04/11/aws-sdk-v3-to-peer-for-your-library.html"&gt;aws-sdk v3 を使うライブラリを作ったときは、なるべく peerDependencies に設定しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本記事&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;私の思う現時点でのベストプラクティス&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CIのイメージは公式の Lambda Docker イメージが便利&lt;/li&gt;
&lt;li&gt;aws-sdk v3 のユニットテストには aws-sdk-client-mock が良い&lt;/li&gt;
&lt;li&gt;aws-sdk の各モジュールのバージョンは揃えて、なるべく最新を使おう&lt;/li&gt;
&lt;li&gt;aws-sdk 関数/クラス以外、たとえば enum の値などは基本的に利用しない&lt;/li&gt;
&lt;li&gt;peerDependencies に書いてあるモジュールもバージョンを揃えてインストールしよう&lt;/li&gt;
&lt;li&gt;packages にあるドキュメントなしのモジュールを使う場合は、zip に含める

&lt;ul&gt;
&lt;li&gt;zip の容量に余裕があれば aws-sdk はすべて含めた方が良い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;現時点はかなりクセがあるというか、ノウハウが必要であるというのが現実だと思います。
とくに AWS Lambda + aws-sdk v3 + TypeScript の場合にはですね。&lt;/p&gt;

&lt;p&gt;ぶっちゃけ TypeScript でなければコンパイルエラーや型違反についての問題もないし、しいていえば zip に含めるかどうか？ぐらいです。
とはいえ、みんなもう Node.js ランタイム選ぶなら TypeScript 使うだろうと思うので、これまでの記事のノウハウが役に立てば幸いです。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ts-jest が esbuild/swc をトランスフォーマーに使って高速化していた</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/13/ts-jest-will-gradually-opt-in-adoption-of-esbuild-swc-more-to-improve-the-performance.html"/>
    <id>http://blog.url.com/2023/04/13/ts-jest-will-gradually-opt-in-adoption-of-esbuild-swc-more-to-improve-the-performance.html</id>
    <published>2023-04-13T14:54:00+09:00</published>
    <updated>2023-04-13T15:09:00+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;昨年 &lt;a href="/2022/05/03/swc-node-jest.html"&gt;@swc-node/jest を使ってテストを高速化する&lt;/a&gt; という記事を書きました。
その時点で ts-jest でのテストが遅くて、 &lt;code&gt;@swc-node/jest&lt;/code&gt; に切り替えていました。&lt;/p&gt;

&lt;p&gt;その後 &lt;code&gt;@swc-node/jest&lt;/code&gt; もなんやかんやあって、たまに動かなくなったりして issue 投稿して直してもらったりいろいろあったのですが、最近 ts-jest の状況を見てみたら、こんな記述がありました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Starting from v28.0.0, ts-jest will gradually opt in adoption of esbuild/swc more to improve the performance. To make the transition smoothly, we introduce legacy presets as a fallback when the new codes don&amp;rsquo;t work yet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;from https://kulshekhar.github.io/ts-jest/docs/getting-started/presets&lt;/p&gt;

&lt;p&gt;なんと、高速化のために esbuild/swc を使うようになったって。まじかー&lt;/p&gt;

&lt;h3&gt;早速 ts-jest に変えてみた&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@swc-node/jest&lt;/code&gt; から &lt;code&gt;ts-jest&lt;/code&gt; に変更して、 &lt;code&gt;jest.config.js&lt;/code&gt; を &lt;code&gt;preset&lt;/code&gt; に変更。
テストを実行してみると、確かに速くなってる！&lt;/p&gt;

&lt;p&gt;手元のプロジェクトだと、 &lt;code&gt;ts-jest&lt;/code&gt; にかかる時間は、 &lt;code&gt;@swc-node/jest&lt;/code&gt; + &lt;code&gt;tsc&lt;/code&gt; の時間とほぼ一致していました。
&lt;code&gt;ts-jest&lt;/code&gt; ではコンパイルエラーも検知されるので、つまりそういうことでしょう。&lt;/p&gt;

&lt;h3&gt;また ts-jest で大丈夫！&lt;/h3&gt;

&lt;p&gt;ということで、 jest の実行に swc や esbuild を使うことや、tsconfig と違う設定を考慮したりとかなく、TypeScript のコードを jest でテストできるようになりました。&lt;/p&gt;

&lt;p&gt;私たちのプロジェクトは、早速すべて ts-jest@29 に切り替えました。
もし問題がある場合は、 Preset にレガシーモードを指定すると esbuild や swc を使わないようにできるようですが、そもそも一度 swc に切り替えてテストできていれば、問題なく ts-jest に戻れるはずです。&lt;/p&gt;

&lt;p&gt;今後は TypeScript + jest での開発環境に ts-jest のご利用をお勧めします。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>aws-sdk v3 を使うライブラリを作ったときは、なるべく peerDependencies に設定しよう</title>
    <link rel="alternate" href="http://blog.url.com/2023/04/11/aws-sdk-v3-to-peer-for-your-library.html"/>
    <id>http://blog.url.com/2023/04/11/aws-sdk-v3-to-peer-for-your-library.html</id>
    <published>2023-04-11T16:33:00+09:00</published>
    <updated>2023-04-11T17:02:45+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;先日 &lt;a href="/2023/04/06/aws-sdk-v2-will-be-mentenance-mode-in-2023.html"&gt;aws-sdk v2 が 2023 年中にメンテナンスモードになる&lt;/a&gt; という記事を書いて、実際自分たちで作っていた aws-sdk v2 でできていた CLI ツールも aws-sdk v3 に切り替えました。&lt;/p&gt;

&lt;h3&gt;CLIツールを v3 に移行したら、利用するアプリ側がコンパイルエラーになる&lt;/h3&gt;

&lt;p&gt;で、それを Lambda にデプロイするアプリの devDependencies に反映してみたところ、また型エラーが出るようになりました。&lt;/p&gt;

&lt;p&gt;CLIツールでは &lt;code&gt;@aws-sdk/client-lambda@3.310.0&lt;/code&gt; に依存していて、 Lambda アプリ側は &lt;code&gt;@aws-sdk/client-lambda@3.254.0&lt;/code&gt; を使っていたためです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;error TS2345: Argument of type &amp;lsquo;typeof LambdaClient&amp;rsquo; is not assignable to parameter of type &amp;lsquo;InstanceOrClassType&lt;Client&lt;ServiceInputTypes, MetadataBearer, any&gt;&amp;gt;&amp;rsquo;.
      Type &amp;lsquo;typeof LambdaClient&amp;rsquo; is not assignable to type &amp;lsquo;ClassType&lt;Client&lt;ServiceInputTypes, MetadataBearer, any&gt;&amp;gt;&amp;rsquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;で、それぞれの型定義への依存は &lt;code&gt;&amp;quot;@aws-sdk/types&amp;quot;: &amp;quot;*&amp;quot;&lt;/code&gt; になっているので、lock ファイルの状態次第でそれぞれでバージョンが異なるものが入る場合があります。
そこで型が一致しない問題が発生してきます。&lt;/p&gt;

&lt;p&gt;CLI ツールでは実行時に aws-sdk が必要になるので、 dependencies に設定していて、CLIツールを使う方のアプリは devDependencies に設定しているわけですが、それぞれの dependencies からインストールされる &lt;code&gt;@aws-sdk/types&lt;/code&gt; がドッチ？問題になってしまうという&amp;hellip;&lt;/p&gt;

&lt;h3&gt;解決策&lt;/h3&gt;

&lt;p&gt;今回は自分たちで作ったライブラリだったので、CLIツール側の aws-sdk を devDependencies に変更して、CLIツールを使うアプリ側の aws-sdk 利用状況に依存するように変更しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight javascript"&gt;&lt;code&gt;  &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;peerDependencies&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;@aws-sdk/client-lambda&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="dl"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;^3.0.0&lt;/span&gt;&lt;span class="dl"&gt;"&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これでアプリ側が &lt;code&gt;@aws-sdk/client-lambda&lt;/code&gt; を使っていればそのバージョンに依存するようになるし、使っていなければ 3系の最新が入るようになります。&lt;/p&gt;

&lt;p&gt;ここで、この aws-sdk v3 シリーズを読んでいただいた懸命な皆様はお気づきだと思いますが &lt;a href="/2023/04/05/aws-sdk-v3-changed-enum-to-const.html"&gt;Node.js v18 / aws-sdk v3 の Lambda アプリが突然動かなくなる&lt;/a&gt; でも書いた&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;peerDependencies&lt;/code&gt; が指定されていたら、バージョンを揃えるために自分でインストールする&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これが重要になってきます。
なので、自分で作ったライブラリで peerDependencies に指定したら、結局アプリ側で使ってなくてもバージョンを揃えるのに追加でインストールした方が良いということです。&lt;/p&gt;

&lt;h3&gt;aws-sdk v3 を安心して使うためには（追記）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;基本的にバージョンは最新版、もしくは最新に近い同じバージョンに揃える&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peerDependencies&lt;/code&gt; が指定されていたら、バージョンを揃えるために自分でインストールする&lt;/li&gt;
&lt;li&gt;関数/クラス以外、たとえば enum の値などは基本的に利用しない&lt;/li&gt;
&lt;li&gt;自作ライブラリで aws-sdk v3 に依存する場合は &lt;code&gt;peerDependencies&lt;/code&gt; に指定する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大事なこと4つ目を追加しました。&lt;/p&gt;

&lt;p&gt;aws-sdk@v3 のパッケージ管理に日々不安が募りますが、同様の問題に遭遇した人の解決に役立てれば幸いです。&lt;/p&gt;
</content>
  </entry>
</feed>
